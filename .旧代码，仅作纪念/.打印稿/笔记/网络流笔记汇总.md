# 二分图

# 8.2

## [P1129](https://www.luogu.com.cn/problem/P1129)

- 树是一个二分图
- 最大流复杂度为 `O(nm)`
- 二分图复杂度为 $O(n \sqrt n)$

## [P1129](https://www.luogu.com.cn/problem/P1129)

- 简述：
  - 矩阵可交换行列，求是否能使主对角线为 1
- 仅交换一方即可，两方无用



# 费用流笔记

## 拆式子拆点

套板子

将题意转化为板子

### [P2053](https://www.luogu.com.cn/problem/P2053) *

#### 前言：

本蒟蒻觉得这道题出的不错，一开始我只想到了二分答案，根本没有想到如何构造网络流，看了题解后才大概理解的。

------

#### 思路：

假设我们现在只有一个修车师傅，共有A1,A2...An这n辆车，那么所有人的等待时间就分别为:

A1+A2...+An,A2+A3+..+An,...,An−1+An,An。
 **那所有人的等待时间呢？**
 加起来，我们发现所有人的等待时间应该是:

A1∗n+A2∗(n−1)+...+An

**那我们对每辆车被等待的时间考虑，发现越后修的被等待的时间越少** 

**而且显而易见的，所有车被等待的时间即为所有人等待的时间 ** 

------

#### 做法：

那我们从每辆车被等待的时间思考，思路也不是很难了，

将M位师傅拆成N∗M个点，第(i−1)∗N+j个点表示的是在修第jj辆车的第ii位师傅，并将这个点连向每辆车，容量为1，边权为Cki∗j（Ci为第i辆车被第j位师傅修所花的时间,1<=k<=N），

然后再源点朝M个车点建边，N∗M个师傅点朝汇点建边，都是边权为0，容量为1的边，最后跑最小费用最大流就行了。

~~同时建反向边应该不用我赘述了吧~~

**注：本来是先修被等的时间越多，但是反过来仔细想先也没有什么问题**

### [P3159 ](https://www.luogu.com.cn/problem/P3159)  *

#### 此题算法:费用流

题目很简洁，做法很恶心的典型。

因为是网络流题，所以模板就不说了，只考虑**加边**。

**大致思路：**

**简化问题**

记录初始和结束状态，把**白棋**看作没棋。

把开始结束**都有黑棋**的格子看作没棋。

如果开始结束时**黑棋数**不等，−1−1 掉。

**加边**

**1.拆点，每个格子有格子 xx和格子 yy。**

> 控制格子交换次数。

**2.ss 向每个黑棋格 xx 连流量 11 费用 00 的边。**

> 表示需匹配状态。

**3.每个黑棋格 yy 向 tt 连流量 11 费用 00 的边。**

> 表示匹配状态。

**4.每个格子 xx 向对应 yy 连流量 ((允许交换数÷2)÷2) 费用 00的边。**

> 两次交换只会消耗 11 的流量。

**※.如果格子初始或结束时有黑棋**并且**允许交换数为奇数，在上面那条边上附上 11的流量。**

> 不交换本来就要通过的流量。

**5.每个格子 yy 向八连通的格子 xx 连流量 inf⁡inf 费用 11 的边。**

> 用来交换。

**然后跑模板就好了，网络流的题都差不多。**

## 输出方案

[P2770](https://www.luogu.com.cn/problem/P2770) [P3356](https://www.luogu.com.cn/problem/P3356) 

对于每条路径，从起点开始搜索，每搜到一个点，选一条反向边有剩余容量（说明被走过）的临边走过去，并把反向边的剩余容量减去 1，直到走到终点。

```c++
    for (int i = 0; i < n - 1;) {
        cout << names[i] << '\n';
        for (int j = g.r[i + n]; ~j; j = g.t[j]) {
            if (!g.e[j].f && g.e[j ^ 1].c) {
                g.e[j ^ 1].c --;
                i = g.e[j].v;
                break;
            }
        }
    }
    for (int i = n - 1; i > 0;) {
        cout << names[i] << '\n';
        for (int j = g.r[i]; ~j; j = g.t[j]) {
            if (!g.e[j].f && g.e[j].c) {
                i = g.e[j].v - n;
                break;
            }
        }
    }
```

```c++
    for (int i = 0; i < n; i += 1) {
        int x = 0, y = 0;
        int now = id[x][y][0];
        for (; x != p - 1 || y != q - 1; ) {
            for (int j = g.r[now ^ 1]; ~j; j = g.t[j]) {
                if (!g.e[j ^ 1].c) {
                    continue;
                }
                for (int c = 0; auto [dx, dy] : d) {
                    auto [tx, ty] = make_pair(x + dx, y + dy);
                    if (leg(tx, ty) && id[tx][ty][0] == g.e[j].v) {
                        cout << i + 1 << ' ' << c << '\n';
                        x = tx, y = ty;
                        now = g.e[j].v;
                        break;
                    }
                    ++ c;
                }
                g.e[j ^ 1].c --;
                break;
            }
        }
    }
```

## 数据结构优化建图

[P5331](https://www.luogu.com.cn/problem/P5331) 

cdq优化建图

## 一流对区间流问题

都能用最小费用可行流来做

### 限制单点最大值问题

[P3358](https://www.luogu.com.cn/problem/P3358) 

### 限制单点最小值问题

[P3980](https://www.luogu.com.cn/problem/P3980) 

每个点向下一个点连 inf - w[i], 0

每个区间的左端点向右端点 + 1连 inf, c

由于最大流思想，费用流会满足条件

## 动态加点问题

[P2053](https://www.luogu.com.cn/problem/P2053) 

[P2050](https://www.luogu.com.cn/problem/P2050) 

其实根据上面的建模可以发现，好多 (j,w) 的点是没有用到的。

根据上述的贪心证明可知：被用到的一定是从 (j,1) 开始的连续的几个层。

那么我们为什么不一边跑流一边加点呢？这样我们就能省去很多无用的点。

我们设第 j 个厨师已经加到了第 topj 层。若再一次跑流之后，(j,topj) 被用掉了，那么我们直接把 (j,topj+1) 加进图里面就好了。

这样点数的规模就降到了 O(n+m+p)，边数的规模降到了 O(np)。

## 费用流最小路径覆盖

### [P2469](https://www.luogu.com.cn/problem/P2469) 

对于所有东西都得经过

1.由源点向第一部分点连容量为1，费用为零的点。

2.由第二部分点向汇连容量为1，费用为零的点。

3.由第一部分点向第二部分点连容量为1，费用为耗时。

4.源点向第二部分的点连容量为1，费用为航行时间。

5.最后跑一边最小费用最大流，即可求出答案。

## 最大权完美匹配

[P3967](https://www.luogu.com.cn/problem/P3967) 关键边

[P4134](https://www.luogu.com.cn/problem/P4134) 必须选择两个，考虑对称选取答案，拆点


## 费用流二分 

[P3705](https://www.luogu.com.cn/problem/P3705) 分数规划

## Dilworth定理

![754e546abc34113328406dd91512d1d0](网络流笔记汇总.assets/754e546abc34113328406dd91512d1d0.png)

![image-20240827154128820](网络流笔记汇总.assets/image-20240827154128820.png)

## 限制性匹配问题

### [JSOI2009](https://www.luogu.com.cn/problem/P4307) 球队收益 / 球队预算

#### 题目描述

在一个篮球联赛里，有$n$支球队，球队的支出是和他们的胜负场次有关系的，具体来说，第i支球队的赛季总支出是$C_i\times x^2+D_i \times y^2,D_i \le C_i$。(赢得多，给球员的奖金就多嘛)
其中$x,y$分别表示这只球队本赛季的胜负场次。现在赛季进行到了一半，每只球队分别取得了$a_i$场胜利和$b_i$场失利。而接下来还有$m$场比赛要进行。问联盟球队的最小总支出是多少。

![P4307](网络流笔记汇总.assets/P4307.png)

### P4249 [WC2007](https://www.luogu.com.cn/problem/P4249) 剪刀石头布  

## 题目描述

> 在一些一对一游戏的比赛（如下棋、乒乓球和羽毛球的单打）中，我们经常会遇到 $A$ 胜过 $B$，$B$ 胜过 $C$ 而 $C$ 又胜过 $A$ 的有趣情况，不妨形象的称之为剪刀石头布情况。有的时候，无聊的人们会津津乐道于统计有多少这样的剪刀石头布情况发生，即有多少对无序三元组 $(A,B,C)$，满足其中的一个人在比赛中赢了另一个人，另一个人赢了第三个人而第三个人又胜过了第一个人。注意这里无序的意思是说三元组中元素的顺序并不重要，将 $(A, B, C)$、$(A, C, B)$、$(B, A, C)$、$(B, C, A)$、$(C, A, B)$ 和 $(C, B, A)$ 视为相同的情况。
>
> 有 $N$ 个人参加一场这样的游戏的比赛，赛程规定任意两个人之间都要进行一场比赛：这样总共有 $\frac{N*(N-1)}{2}$ 场比赛。比赛已经进行了一部分，我们想知道在极端情况下，比赛结束后最多会发生多少剪刀石头布情况。即给出已经发生的比赛结果，而你可以任意安排剩下的比赛的结果，以得到尽量多的剪刀石头布情况。

反向考虑没有三元环的情况

得到差分建图

![简化建图](网络流笔记汇总.assets/简化建图.png)

### [ZJOI2011](https://www.luogu.com.cn/problem/P4542) 营救皮卡丘

> 题目描述
>
> 皮卡丘被火箭队用邪恶的计谋抢走了！这三个坏家伙还给小智留下了赤果果的挑衅！为了皮卡丘，也为了正义，小智和他的朋友们义不容辞的踏上了营救皮卡丘的道路。
>
> 火箭队一共有$N$个据点，据点之间存在$M$条双向道路。据点分别从$1$到$N$标号。小智一行$K$人从真新镇出发，营救被困在$N$号据点的皮卡丘。为了方便起见，我们将真新镇视为$0$号据点，一开始$K$个人都在$0$号点。
>
> 由于火箭队的重重布防，要想摧毁$K$号据点，必须按照顺序先摧毁$1$到$K-1$号据点，并且，如果$K-1$号据点没有被摧毁，由于防御的连锁性，小智一行任何一个人进入据点$K$，都会被发现，并产生严重后果。因此，在$K-1$号据点被摧毁之前，任何人是不能够经过$K$号据点的。
>
> 为了简化问题，我们忽略战斗环节，小智一行任何一个人经过$K$号据点即认为$K$号据点被摧毁。被摧毁的据点依然是可以被经过的。
>
> $K$个人是可以分头行动的，只要有任何一个人在$K-1$号据点被摧毁之后，经过$K$号据点，$K$号据点就被摧毁了。显然的，只要$N$号据点被摧毁，皮卡丘就得救了。
>
> 野外的道路是不安全的，因此小智一行希望在摧毁$N$号据点救出皮卡丘的同时，使得$K$个人所经过的道路的长度总和最少。
>
> 请你帮助小智设计一个最佳的营救方案吧！

我们尝试将上述模型应用到此题中。首先，每个人都从 0 号点出发，所以 0 可以作为 K 条路径的起点，因而它可以与 K 个点匹配。所以 <S,0out> 这条边的流量我们要改成 K。此外我们要引进费用的概念，每次匹配就代表使用了这条边，也就要消耗这条边的代价。这样图就建完了，跑费用流即可。

### [洞穴遇险](https://www.luogu.com.cn/problem/P4142) 

>题目描述
>
>整个洞穴是一个$N*N$的方格图，每个格子形如$(X,Y),1 \le X,Y \le N$。其中$X$表示从上到下的行数，$Y$表示从左到右的列数。$(1,1)$在左上角,$(1,N)$在右上角，$(N,1)$在左下角，$(N,N)$在右下角。
>
>满足$X+Y$为奇数格子的有一个不稳定度$V_{X,Y},X+Y$为偶数的格子的不稳定度为$0$。
>
>**ZRQ**现在手里恰巧有$M$个可以支撑洞穴的柱子，柱子的力量可以认为是无穷大。
>
>只要支撑住了一个格子那么这个格子的不稳定度将降为$0$。
>
>每个柱子是$L$型的，它除了要占据当前的格子外，还需要占据两个相邻的格子（这三个格子形成$L$型,可以选择任意方向放置，一共有$4$个方向）。
>
>![](https://cdn.luogu.com.cn/upload/pic/13049.png) 
>
>**柱子占据相邻的格子不会降低其不稳定度（换句话说就是柱子只有在拐角处有力量)**。
>
>有些格子的顶已经塌下来了，无法在其位置放置柱子了，这些格子也不能被占据了。这样已经塌了的格子有$K$个（他们的不稳定度都为$0$,**即使$X+Y$为奇数，塌下来的格子的不稳定度也会为$0$**）。
>
>**ZRQ**想问你，在放置一些柱子后 ，最小的不稳定度之和为多少（可以不将$M$个柱子都放完）。

一般连续选三个的问题都是黑白染色

![选择](网络流笔记汇总.assets/选择.png) 

# 分层图思想

## 长度限制性条件

### 最长不下降子序列

[P2766](https://www.luogu.com.cn/problem/P2766) 

[P3308](https://www.luogu.com.cn/problem/P3308) 

# 小规模建图思想

在不清楚使用什么模型时，可以使用小规模数据模拟，最后得到一个较好的模型

# 对偶图思想

平面图最小割转对偶图最短路

## 网络流的退流

我们发现，如果是加边的话，可以直接加进去然后直接在原来跑完的基础上继续跑，而难处理的是减边。

这个时候我们就用到优秀的退流啦！假设源点和汇点是 S 和 T，要删去一条边 ( u , v ) ，那么我们只需要以 u 为源点，向 S 跑一次最大流，然后再以 T 为源点，向 v 跑一次最大流即可。最后将 ( u , v )  这条边以及其反向边的流量设为 0 即可。

### [P3308](https://www.luogu.com.cn/problem/P3308) *

或者直接手动全部退流，甚至更快doge

## 一选二问题

### [P1231  ](https://www.luogu.com.cn/problem/solution/P1231) 

### [P2891](https://www.luogu.com.cn/problem/P2891) 

转换为

![图示](网络流笔记汇总.assets/图示.png)

## 最小化最小割和割边数量

[P1344](https://www.luogu.com.cn/problem/solution/P1344)

因为本题既要输出最小割的值又要输出割的边数，前者好求关键是后者如何去求更简单，容易想到我们可以直接建两次图，一次按原边权建图跑最大流求得最小割，再按边权为1建图跑最大流求割的边数，这是一种思路;

当然我们完全可以换种思路用一次最大流搞定，只需建图时将边权w=w*a+1（w为本来的边权，a为大于1000的数），这样我们能求得最大流ans，则最小割的值为ans/a，割的边数为ans%a。这很容易理解，但是还是解释一下：因为最小割的边集中有w1+w2+w3…+wn=ans（这个ans为本来的最小割），所以必然有w1*a+w2*a+w3*a…+wn*a=ans*a，于是必然有w1*a+1+w2*a+1+w3*a+1…+wn*a+1=ans*a+k(k为最小割的边数，k<=m<=1000)，这样就很明显了，因为边数m不大于1000，所以k的最大值为1000，我们只要使设定的a的值大于1000，那么按上述方法建图，跑出的最大流除以a就是最小割的值ans，最大流模a就是最小割的边数k。

## 二分答案 网络流

[P2402](https://www.luogu.com.cn/problem/P2402) 

二分答案 + 网络流

建图：

1、源点 → 每块田，边权为牛的数量

2、每个牛棚 → 汇点，边权为牛棚最多能容纳的牛

3、对中间的边进行二分答案。具体操作如下。

使用 floyd 对两个点之间的最短距离预处理，对最小时间进行二分答案。如果在这个时间内可以从 ii 号田地走向 jj 号牛棚，就连一条边，容量为 ∞ ，最终检验最大流是否等于牛的数量即可。

[P3425](https://www.luogu.com.cn/problem/P3425) 

### 并行思维

[P3153](https://www.luogu.com.cn/problem/P3153) 

如果这题换个问法：能不能跳a支舞曲

我们来看看

把每个人拆成喜欢和不喜欢两个点

从S向每个男生连容量为a的边，表示限制a支舞曲

再从男生连向喜欢和不喜欢的两个点，

但是这样子没法限制，因为只说了不能和超过K个不喜欢的人跳舞

所以可以直接从S连向男生喜欢，容量为a

再从男生喜欢连向男生不喜欢连边，容量为K

这样的话就解决了这个问题

接下来就很好办了

男生喜欢连向女生喜欢

男生不喜欢连向女生不喜欢

而女生之间的连边类似于男生

（你就想，如果这个图反过来是一样的，所以怎么连边就很清晰了）

这个时候跑最大流

求出来的就是最大的匹配数

如果最大流恰好等于a*n

也就是恰好a*n组匹配，意味着可行

现在再来看这个问题

既然要求最大的a

所以就二分一下

然后每次把图重构一下流量

二分就行了

图论中除了匹配和边覆盖可以做一般图，其它均是 np 困难问题

由于带花树算法无用，所以（一般）没有一般图的情形

## 最小不相交路径覆盖问题

往往这样建图

![最小路径覆盖模型](网络流笔记汇总.assets/最小路径覆盖模型.png)

### [P2764](https://www.luogu.com.cn/problem/P2764)

#### 题目描述

给定有向图 $G=(V,E)$ 。设 $P$ 是 $G$ 的一个简单路（顶点不相交）的集合。如果 $V$ 中每个定点恰好在 $P$ 的一条路上，则称 $P$ 是 $G$ 的一个路径覆盖。$P$ 中路径可以从 $V$ 的任何一个定点开始，长度也是任意的，特别地，可以为 $0$。$G$ 的最小路径覆盖是 $G$ 所含路径条数最少的路径覆盖。设计一个有效算法求一个 DAG（有向无环图）$G$ 的最小路径覆盖。

### [P2765](https://www.luogu.com.cn/problem/P2765)

还没搞懂正确性

### [P2172](https://www.luogu.com.cn/problem/P2172)

版

### DAG的最小可相交路径覆盖 杂

**算法**：先用floyd求出原图的传递闭包，即如果a到b有路径，那么就加边a->b。然后就转化成了最小不相交路径覆盖问题。

**证明**：为了连通两个点，某条路径可能经过其它路径的中间点。比如1->3->4，2->4->5。但是如果两个点a和b是连通的，只不过中间需要经过其它的点，那么可以在这两个点之间加边，那么a就可以直达b，不必经过中点的，那么就转化成了最小不相交路径覆盖。

[链接](https://blog.csdn.net/qq_39627843/article/details/82012572) 

### [P5769](https://www.luogu.com.cn/problem/P5769) 

以事件为中心建图，忽略原图，看起来并行的事件转化为最小不相交路径覆盖问题

## 二分图多重匹配问题

比较简单

### [P3254](https://www.luogu.com.cn/problem/P3254) [P2763](https://www.luogu.com.cn/problem/P2763)

裸体

## 二分图最大独立集

注意不要建立双向边，否则会神秘wa

[P3355](https://www.luogu.com.cn/problem/P3355) [P4304](https://www.luogu.com.cn/problem/solution/P4304)

## 多源点多汇点网络流的特殊情况 ———— 二源点二汇点，指定流向

### [P3163](https://www.luogu.com.cn/problem/P3163) *

交换一方缘汇点跑两次，正确即可

另外：

我们已经介绍了如何求解恰有一个源点和一个汇点的网络流。那么，如果有多个源点和汇点，并且它们都有对应的最大流出容量和流入容量限制时该怎么做呢？答案很简单，只要增加一个超级源点 s 和一个超级汇点 t ,从 s  向每个源点连一条容量为对应最大流出容量的边，从每个汇点向 t 连一条容量为对应最大流入容量的边。不过，如果源和汇之间存在对应关系（从不同源点流出的流要流入指定的汇点）时，是无法这样求解的。这种情况被称为多物网络流问题，尚未有已知的高效算法，这类问题也几乎不会出现在程序设计竞赛当中

## 二分图最大点覆盖集

先说一下什么叫二分图的最小点覆盖，简而言之就是我们希望用尽可能少的点去使所有的边都被选中，这里解释一下：如果说一条边的任意一个顶点被选中那么这条边也被选中。

Konig定理：二分图中，最小点覆盖数 = 最大匹配数。



# 8.3

## 二分图最小割

默念一百遍：满足二选一的性质就是二分图

### [P1361](https://www.luogu.com.cn/problem/P1361)  [P2774](https://www.luogu.com.cn/problem/P2774) 虚点

意见相同利益，构建

![乱搞成果](https://cdn.luogu.com.cn/upload/image_hosting/ximtf967.png)

### [P4174](https://www.luogu.com.cn/problem/P4174)

将代价提前付出，转化为利益二分图

### [P2057](https://www.luogu.com.cn/problem/P2057)

意见相左利益构建双向边（因为无法判断方向），流量为利益

### [P2774](https://www.luogu.com.cn/discuss?forum=P2774)

- 简述：矩阵邻边不能选，选任意数总和最大
- 二分最大独立集
  - 图论中除了匹配和边覆盖可以做一般图，其它均是 np 困难问题
  - 所以独立集询问问题里面一定是二分图

## 生成树换边

### [P5039](https://www.luogu.com.cn/problem/P5039) *

将最小生成树换边的本质和最小割联系起来

### [P5934](https://www.luogu.com.cn/problem/P5934#submit) *

最小生成树和最大生成树都做

## 带限制条件的最小割  ————  回流边的研究

### [P5039](https://www.luogu.com.cn/problem/P5039)

- 题目描述

  - 经过千辛万苦小 A 得到了一块切糕，切糕的形状是长方体，小 A 打算拦腰将切糕切成两半分给小 B。出于美观考虑，小 A 希望切面能尽量光滑且和谐。于是她找到你，希望你能帮她找出最好的切割方案。

  - 出于简便考虑，我们将切糕视作一个长 $P$、宽 $Q$、高 $R$ 的长方体点阵。我们将位于第 $z$ 层中第 $x$ 行、第 $y$ 列上的点称 $(x,y,z)$，它有一个非负的不和谐值 $v(x,y,z)$。一个合法的切面满足以下两个条件：

    - 与每个纵轴（一共有 $P\times Q$ 个纵轴）有且仅有一个交点。即切面是一个函数 $f(x,y)$，对于所有 $(x,y)(x\in [1,P],y\in[1,Q])$，我们需指定一个切割点 $f(x,y)$，且 $1\le f(x,y)\le R$。

    - 切面需要满足一定的光滑性要求，即相邻纵轴上的切割点不能相距太远。对于所有的 $1\le x,x'\le P$ 和 $1\le y,y'\le Q$，若 $|x-x'|+|y-y'|=1$，则 $|f(x,y)-f(x',y')| \le D$，其中 $D$ 是给定的一个非负整数。


  - 可能有许多切面 $f$ 满足上面的条件，小 A 希望找出总的切割点上的不和谐值最小的那个。

回流边的作用可以反证法证明

![QQ_1722754239901](网络流笔记汇总.assets/QQ_1722754239901.png)

### [P6054](https://www.luogu.com.cn/problem/P6054)

粗略分析：反向边只能截断作用

![QQ_1722758844185](网络流笔记汇总.assets/QQ_1722758844185.png)

粗略分析：正向边强制正向

![QQ_1722758926763](网络流笔记汇总.assets/QQ_1722758926763.png)

实际上两者是一样的，只能选顺时针更倾斜的方向，建出两次边时只能选择夹角方向

![QQ_1722759413891](网络流笔记汇总.assets/QQ_1722759413891.png)

注意细节

![QQ_1722760133834](网络流笔记汇总.assets/QQ_1722760133834.png)

![094cf9a115c2662a94da06734790bd78](网络流笔记汇总.assets/094cf9a115c2662a94da06734790bd78.png)

![5c05fe3d82e82cbe62adc91fb0ebc9e3](网络流笔记汇总.assets/5c05fe3d82e82cbe62adc91fb0ebc9e3.png)

## 最小割树

一个图中只有最多n种不同的最小割

建树代码

```c++
    vector<int> a(n);
    iota(a.begin(), a.end(), 0);
    vector<vector<array<i64, 2>>> adj(n);
    auto build = [&] (auto &&build, int l, int r) -> void {
        if (r - l == 0) {
            return;
        }
        int u = a[l], v = a[r];
        i64 cap = g.flow(u, v);
        adj[u].push_back({v, cap});
        adj[v].push_back({u, cap});
        cout << u + 1 << ' ' << v + 1 << ' ' << cap << '\n';
        auto c = g.minCut();
        for (int i = l, j = r; i < j; i += 1) {
            for (; i < j && c[a[i]] == 1 && c[a[j]] == 1; j -= 1);
            if (i < j && c[a[i]] == 1) {
                swap(a[i], a[j]);
            }
        }
        int m = l;
        while (m < r && !c[a[m + 1]]) m ++;
        for (int i = 0; i < g.c.size(); i += 2) {
            tie(g.c[i], g.c[i + 1]) = make_pair(g.c[i] + g.c[i + 1], 0);
        }
        build(build, l, m);
        build(build, m + 1, r);
    };
    build(build, 0, n - 1);
```

###  [P4123](https://www.luogu.com.cn/problem/P4123)  [P4897](https://www.luogu.com.cn/problem/P4897) [P3329](https://www.luogu.com.cn/problem/P3329)

板子

## 最小割最大闭合子图模型

### [P2762](https://www.luogu.com.cn/problem/P2762) [P4174](https://www.luogu.com.cn/problem/P4174)

将代价提前支出，转化为虚点经典模型

公式化说明

> 给定一个有向图，点有点权，选择一个子图，满足子图上**如果选择了一个点就必须选择它后继的所有点**。最大化点权和。

这是一个经典的网络流问题，如果一个点被选择了则后继必须被选择，那么称该图是 **闭合的**，因此该问题叫做**最大权闭合子图问题**。可以使用最小割解决。

具体的建图方法为：

> 源点向所有正权点连结一条容量为权值的边
>
> 保留原图中所有的边，容量为正无穷
>
> 所有负权点向汇点连结一条容量为权值绝对值的边

则原图的最大权闭合子图的点权和即为所有正权点权值之和减去建出的网络流图的最小割。

### [P2057](https://www.luogu.com.cn/problem/P2057)

多重嵌套

#### 拓扑去环

#### [P2805](https://www.luogu.com.cn/problem/P2805)

## 虚点

### [P1361](https://www.luogu.com.cn/problem/P1361)  [P2774](https://www.luogu.com.cn/problem/P2774)

意见相同利益，构建

![乱搞成果](https://cdn.luogu.com.cn/upload/image_hosting/ximtf967.png)

### [P1935](https://www.luogu.com.cn/problem/P1935)  对于对立情况进行黑白染色

a 与 b的染色情况对立时，获得利益 c，那么黑白染色建图即可

## 不好归类，但相当经典

### [P4177](https://www.luogu.com.cn/problem/P4177) ?

# 问题集锦

## 传递性失效

[P6054](https://www.luogu.com.cn/problem/P6054)

注意细节

![QQ_1722760133834](网络流笔记汇总.assets/QQ_1722760133834.png)

![094cf9a115c2662a94da06734790bd78](网络流笔记汇总.assets/094cf9a115c2662a94da06734790bd78.png)

![5c05fe3d82e82cbe62adc91fb0ebc9e3](网络流笔记汇总.assets/5c05fe3d82e82cbe62adc91fb0ebc9e3.png)

## 最小割相同权值产生多割点假象

板子使用示例

```c++
    g.flow(s, t + n);
    auto e = g.edges();
    auto minCut = g.minCut();
    vector<int> ans;
    for (auto [u, v, c, f] : e) {
        if (minCut[u] && !minCut[v]) {
            ans.push_back(u);
        }
    }

    for (auto i : ans) {
        cout << i + 1 << ' ';
    }
    cout << '\n';
```

`minCut` 表示图中的点在左边还是右边，两边不一样即为最小割

```c++
2
1 2
1
1
```

# Hall 定理 

解决二分图完美匹配问题的充要条件 

> 设二分图左侧有 x 个点，右侧有 y 个点。不妨设 x≤y，则有：
>
> **二分图存在完美匹配 ⟺ ∀k∈[1,x]，均满足从左侧选出 k 个点，连向右侧的点集大小不小于 k**
>
> 二分图完美匹配：匹配数为 min(x,y)。

正确性十分显然。

>最大匹配的一种求法 **推论：** **设左侧点集 S 连向右侧的点集为 T，则二分图最大匹配数为 n−max(|S|−|T|)** 
>
>**霍尔定理的关键在于推狮子转化，维护连续区间是否合法** 
>
>**不定一格，寻找性质** 

#### 1\. [P3488 ](https://www.luogu.com.cn/problem/P3488)

> 滑冰俱乐部初始有 1 到 n 号码溜冰鞋各 k 双，已知 x 号脚的人可以穿 x 到 x+d 号码的鞋子。
>
> 现在有 m 次操作，每次两个数 r、x，表示 r 号脚的人来了 x 个，x 为负表示离开。对于每次操作，输出溜冰鞋是否足够。
>
> r≤n−d，1≤n,k,m≤5×105，k≤109.

很容易想到将人和溜冰鞋一起建二分图，傻瓜式连边，并对于每次操作都跑一遍最大流，但这时间复杂度显然爆炸！

由于题目只询问是否存在完美匹配，所以考虑使用 Hall 定理。

设 sx 为当前脚码为 x 的人数。由 Hall 定理可知，若该二分图存在完美匹配，则有：

∀l,r∈[1,n−d],l≤r,r∑i=lsi≤k×(r−l+1+d)

不妨将右侧常变量分离，则有：

r∑i=l(si−k)≤k×d

于是我们动态维护所有区间 ∑si−k 的最大值，每次询问时判断是否大于 k×d 即可。

用线段树可以做到 O(mlogn).

#### 2\. [CF981F Round Marriage](https://www.luogu.com.cn/problem/CF981F)

> n 个新郎和 n 个新娘围成一个环，长度为 L，第 i 个新郎位置为 ai，第 i 个新娘位置为
> bi，需要将他们两两配对，最小化新郎和新娘距离的最大值。
>
> 1≤n≤2×105，1≤L≤109

首先根据 "最小值最大"，先二分答案，考虑如何判定「当新郎可以和距离其 x 以内的新娘配对时，是否存在完美匹配」。

又观察到了「完美匹配」，考虑使用 Hall 定理。

首先断环成链，设第 ii 个新郎向左可以匹配到第 nli 个新娘，向右可以匹配到第 nri 个新娘。由于单次判定对于每个新郎的 x
值相同，故可以利用单调性 O(n) 求出每个新郎的 nl,nr 值。

那么根据 Hall 定理，有：

r−l+1≤nr−nl+1

观察到该式子只和 l,rl,r 有关，考虑将 l,rl,r 拆开：

nrr−r≥nll−l

于是从左向右扫时，动态更新之前所有 nll−l的最大值，判断是否不大于当前 nr−r 即可。

注意断环时将 a 拆成两份，将 b 拆成四份，才能便捷地在处理中表示所有情况。

时间复杂度 O(nlogn).

#### 3\. [Loj6062.「2017 山东一轮集训 Day2」Pair](https://loj.ac/p/6062)

> 给出一个长度为 n 的数列 ai 和一个长度为 m 的数列 bi，求 ai 有多少个长度为 m 的连续子数列能与 bi 匹配。
>
> 两个数列可以匹配，当且仅当存在一种方案，使两个数列中的数可以两两配对，两个数可以配对当且仅当它们的和不小于 h。
>
> 1≤m≤n≤1.5×105，1≤ai,bi,hi≤109

不妨将 b 数组降序排序，则对于每一个 ai，对应的连边区间都为 b 数组的一个前缀。

所以对于 a 中每一个长度为 m 的区间，都会在 b 中对应 m 个前缀。

设区间内值为 x 的 ai 的个数为 px。根据 Hall 定理，此时需要满足的约束是：

∀x∈[1,m],x∑i=1pi≤x

于是考虑使用权值线段树进行维护，初始将线段树第 i 个位置的值设为 −i。对于每一次区间移动，设需要修改的值为 pk，则在线段树上修改区间
[pk,m] 即可。

判定时查询线段树最大值是否大于 0，并计数。

时间复杂度 O(mlogn).

#### 4\. [CF1009G Allowed Letters](https://www.luogu.com.cn/problem/CF1009G)

> 给定一个长为 n 的串，字符集 a−f。你可以重排这个串，满足指定 m 个位置上只能放特定的字符，m
> 个位置以及字符集会给出，求字典序最小的串。
>
> 1≤m≤n≤105，保证 m 个位置互不重复。

**$bitmask\ sosdp$** 暴力判断

观察到字符集很小，考虑到在字符集上做文章。

不妨从 a 到 f 枚举每个位置都填什么字符，对于当前决策字符 s，若填完 s 后，对于后面的位置，满足对于完美匹配的判定，则说明 s
合法，可以填 s。

于是问题就在于，如何高效判定完美匹配。

具体地，根据 Hall 定理，若存在完美匹配，需满足选出字符集的一个子集后，设子集中余下需填字符总数为 num，剩下位置中还可以填这些字符的位置总数为
tot，则需要满足 num≤tot。但暴力判定这个，单次复杂度仍然是 O(n) 的，炸炸炸！

但是注意到，每次填完一个字符之后，对于每个子集的 num 和 tot 来说是好维护的。于是可以考虑作一个简单的状压
dp，将字符集选择状态压起来，每次填写后，动态维护 numS 和 totS，如此便可以做到 O(1) 判定了。

故最终时间复杂度为 O(|S|n2|S|)，其中 |S|=6.

#### 5\. [[ARC076F] Exhausted?](https://www.luogu.com.cn/problem/AT_arc076_d)

> n 个人，m 张椅子，第 i 个人可以坐在前 li 椅子上或者后 ri 个椅子上，每个人只能坐一把椅子。求最少有几个人坐不到椅子。
>
> 1≤n,m≤2×105，0≤li<ri≤m+1.

首先自然可以想到网络流，使用前后缀优化建图可以拥有较为优秀的复杂度，但是数据范围太大，很难通过本题。

于是考虑使用复杂度更为优秀的类网络流解法，使用 Hall 定理的推论解决本题。

人的集合不好枚举，我们可以考虑枚举枚举前 i 个椅子和后 j 个椅子构成的区间所完全包含的人数。但这仍然是 O(m2) 的。

观察到这其实是二维数点，每次询问其实就是在查询 li∈[1,l] 且 ri∈[r,m] 的人数。

于是可以考虑采用扫描线消维的方式，枚举 l，用线段树维护 r 上的最大值，将 li=l 的所有 ri 扔到线段树里；同时由于 l
的向右扩展，r 左范围默认向右移动。随着扫描的进行动态维护最大值即可。有一些简单的细节需要处理。

时间复杂度 O(mlogm).