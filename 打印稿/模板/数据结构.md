# 数据结构

## linkCutTree

### 标准版

```cpp
template<class Info>
struct linkCutTree {
    struct node {
        int s[2], p, tag;
        Info mval;
    };
    int n;
    vector<node> tree;

    int &fa(int x) { return tree[x].p; }
    int &lc(int x) { return tree[x].s[0]; }
    int &rc(int x) { return tree[x].s[1]; }
    // notroot
    bool pos(int x) {
        return tree[tree[x].p].s[0] == x || tree[tree[x].p].s[1] == x;
    }
    // 不能以0开头
    linkCutTree(int n) : n(n) { tree.resize(n + 1); tree[0].mval.defaultclear(); }

    void pull(int x) {
        tree[x].mval.up(tree[lc(x)].mval, tree[rc(x)].mval);
    }

    void push(int x) {
        if (tree[x].tag) {
            swap(lc(x), rc(x));
            tree[lc(x)].mval.reve();
            tree[rc(x)].mval.reve();
            tree[rc(x)].tag ^= 1;
            tree[lc(x)].tag ^= 1;
            tree[x].tag = 0;
        }
    }

    // maintain
    void mt(int x) {
        if (pos(x)) mt(fa(x));
        push(x);
    }
    // rotate
    void rtt(int x) {
        int y = fa(x), z = fa(y);
        int k = rc(y) == x;
        if (pos(y))
            tree[z].s[rc(z) == y] = x;
        fa(x) = z;
        tree[y].s[k] = tree[x].s[k ^ 1];
        fa(tree[x].s[k ^ 1]) = y;
        tree[x].s[k ^ 1] = y;
        fa(y) = x;
        pull(y);
    }
    void splay(int x) {
        mt(x);
        while (pos(x)) {
            int y = fa(x), z = fa(y);
            if (pos(y))
                ((rc(z) == y) ^ (rc(y) == x))
                ? rtt(x) : rtt(y);
            rtt(x);
        }
        pull(x);
    }       
    // access
    void acc(int x) {
        for (int y = 0; x;) {
            splay(x);
            rc(x) = y;
            pull(x);
            y = x;
            x = fa(x);
        }
    }

    // makeroot
    void mrt(int x) {
        acc(x);
        splay(x);
        tree[x].tag ^= 1;
    }

    //y变成原树和辅助树的根
    const Info &split(int x, int y) {
        mrt(x);
        acc(y);
        splay(y);
        return tree[y].mval;
    }

    // findroot
    int find(int x) {
        acc(x);
        splay(x);
        while (lc (x))
            push(x), x = lc(x);
        splay(x);
        return x;
    }

    void link(int x, int y) {
        mrt(x);
        if (find(y) != x) fa(x) = y;
    }

    void cut(int x, int y) {
        mrt(x);
        if (find(y) == x
            && fa(y) == x && !lc(y)) {
            rc(x) = fa(y) = 0;
            pull(x);
        }
    }

    void modify(int x, const Info &val) {
        splay(x);
        tree[x].mval.modify(val);
        pull(x);
    }

    bool same(int x, int y) {
        mrt(x);
        return find(y) == x;
    }
    node &operator[](int x) {
        return tree[x];
    }
    void dfs(int u) {
        auto dfs = [&] (auto &&dfs, int u, int fa, int from) -> void {
            // push(u);
            for (auto i : {0, 1}) {
                if (i == 1) {
                    cerr << '(' << fa << " [" << from << ']' << " -> "  << u << ')' << ' ';
                    debug(tree[u].s[0], tree[u].s[1]);
                    tree[u].mval.show();
                }
                if (tree[u].s[i]) {
                    dfs(dfs, tree[u].s[i], u, i);
                }
            }
        };
        dfs(dfs, u, u, 0);
    }
};

struct Info {
    void reve() {}
    void modify(const Info& rhs) {}
    void up(const Info &lhs, const Info &rhs) {}
    // default
    void clear() {}
};

using Tree = linkCutTree<Info>;
```

### LazyLinkCutTree

```cpp
template<class Info, class Tag>
struct LazyLinkCutTree {
    struct node {
        int s[2], p, tag;
        Info mval;
        Tag mtag;
    };
    int n;
    vector<node> tree;

    int &fa(int x) { return tree[x].p; }
    int &lc(int x) { return tree[x].s[0]; }
    int &rc(int x) { return tree[x].s[1]; }
    bool pos(int x) {
        return tree[tree[x].p].s[0] == x || tree[tree[x].p].s[1] == x;
    }
    // 不能以0开头
    LazyLinkCutTree(int n) : n(n) { 
        tree.resize(n + 1); 
        tree[0].mtag.clear();
        tree[0].mval.clear();
    }

    void pull(int x) {
        tree[x].mval.up(tree[lc(x)].mval, tree[rc(x)].mval);
    }

    void apply(int x, const Tag &rhs) {
        if (x) {
            tree[x].mval.apply(rhs);
            tree[x].mtag.apply(rhs);
        }
    }

    void push(int x) {
        if (tree[x].tag) {
            swap(lc(x), rc(x));
            tree[lc(x)].mval.reve();
            tree[rc(x)].mval.reve();
            tree[rc(x)].tag ^= 1;
            tree[lc(x)].tag ^= 1;
            tree[x].tag = 0;
        }
        if (bool(tree[x].mtag)) {
            apply(lc(x), tree[x].mtag);
            apply(rc(x), tree[x].mtag);
            tree[x].mtag.clear();
        }
    }

    void mt(int x) {
        if (pos(x)) mt(fa(x));
        push(x);
    }

    void rtt(int x) {
        int y = fa(x), z = fa(y);
        int k = rc(y) == x;
        if (pos(y))
            tree[z].s[rc(z) == y] = x;
        fa(x) = z;
        tree[y].s[k] = tree[x].s[k ^ 1];
        fa(tree[x].s[k ^ 1]) = y;
        tree[x].s[k ^ 1] = y;
        fa(y) = x;
        pull(y);
    }

    void splay(int x) {
        mt(x);
        while (pos(x)) {
            int y = fa(x), z = fa(y);
            if (pos(y))
                ((rc(z) == y) ^ (rc(y) == x))
                ? rtt(x) : rtt(y);
            rtt(x);
        }
        pull(x);
    }

    void acc(int x) {
        for (int y = 0; x;) {
            splay(x);
            rc(x) = y;
            pull(x);
            y = x;
            x = fa(x);
        }
    }

    void mrt(int x) {
        acc(x);
        splay(x);
        tree[x].tag ^= 1;
    }

    //y变成原树和辅助树的根
    const Info &split(int x, int y) {
        mrt(x);
        acc(y);
        splay(y);
        return tree[y].mval;
    }

    int find(int x) {
        acc(x);
        splay(x);
        while (lc (x))
            push(x), x = lc(x);
        splay(x);
        return x;
    }

    void link(int x, int y) {
        mrt(x);
        if (find(y) != x) fa(x) = y;
    }

    void cut(int x, int y) {
        mrt(x);
        if (find(y) == x
            && fa(y) == x && !lc(y)) {
            rc(x) = fa(y) = 0;
            pull(x);
        }
    }

    void modify(int x, const Info &val) {
        splay(x);
        tree[x].mval.modify(val);
        pull(x);
    }

    void lineModify(int u, int v, const Tag &rhs) {
        split(u, v);
        apply(v, rhs);
    }
    
    bool same(int x, int y) {
        mrt(x);
        return find(y) == x;
    }

    node &operator[](int x) {
        return tree[x];
    }
    void dfs(int u) {
        auto dfs = [&] (auto &&dfs, int u, int fa, int from) -> void {
            // push(u);
            for (auto i : {0, 1}) {
                if (i == 1) {
                    cerr << '(' << fa << " [" << from << ']' << " -> "  << u << ')' << ' ';
                    debug(tree[u].s[0], tree[u].s[1]);
                    tree[u].mval.show();
                }
                if (tree[u].s[i]) {
                    dfs(dfs, tree[u].s[i], u, i);
                }
            }
        };
        dfs(dfs, u, u, 0);
    }
};

struct Tag {
    int set = 0;
    void apply(const Tag &rhs) {
        set = rhs.set;
    }
    void clear() {
        set = 0;
    }
    operator bool() {
        return set != 0;
    }
};

struct Info {
    int c = 0; int sum = 0, l = 0, r = 0, id = 0;
    void reve() {
        swap(l, r);
    }
    void modify(const Info& rhs) {
        l = r = c = rhs.c;
    }
    void up(const Info &lhs, const Info &rhs) {
        sum = lhs.sum + (c != lhs.r && lhs.r != 0) + (c != rhs.l && rhs.l != 0) + rhs.sum;
        l = (lhs.r == 0 ? c : lhs.l);
        r = (rhs.l == 0 ? c : rhs.r);
    }
    void apply(const Tag &rhs) {
        l = r = c = rhs.set; sum = 0;
    }
    void show() const {
        debug(id);
        cerr << l << ' ' << c << ' ' << r << ' ' << sum << endl;
    }
    void clear() {}
};

using Tree = LazyLinkCutTree<Info, Tag>;
```

### 维护子树信息

```cpp
template<class Info>
struct linkCutTree {
    struct node {
        int s[2], p, tag;
        Info mval;
    };
    int n;
    vector<node> tree;

    int &fa(int x) { return tree[x].p; }
    int &lc(int x) { return tree[x].s[0]; }
    int &rc(int x) { return tree[x].s[1]; }
    bool pos(int x) {
        return tree[tree[x].p].s[0] == x || tree[tree[x].p].s[1] == x;
    }
    // 不能以0开头
    linkCutTree(int n) : n(n) { tree.resize(n + 1); tree[0].mval.clear(); }

    void pull(int x) {
        // debug(x);
        tree[x].mval.up(tree[lc(x)].mval, tree[rc(x)].mval);
    }
    void push(int x) {
        if (tree[x].tag) {
            swap(lc(x), rc(x));
            tree[lc(x)].mval.reve();
            tree[rc(x)].mval.reve();
            tree[rc(x)].tag ^= 1;
            tree[lc(x)].tag ^= 1;
            tree[x].tag = 0;
        }
    }
    void mt(int x) {
        if (pos(x)) mt(fa(x));
        push(x);
    }

    void rtt(int x) {
        int y = fa(x), z = fa(y);
        int k = rc(y) == x;
        if (pos(y))
            tree[z].s[rc(z) == y] = x;
        fa(x) = z;
        tree[y].s[k] = tree[x].s[k ^ 1];
        fa(tree[x].s[k ^ 1]) = y;
        tree[x].s[k ^ 1] = y;
        fa(y) = x;
        pull(y);
    }
    void splay(int x) {
        mt(x);
        while (pos(x)) {
            int y = fa(x), z = fa(y);
            if (pos(y))
                ((rc(z) == y) ^ (rc(y) == x))
                ? rtt(x) : rtt(y);
            rtt(x);
        }
        pull(x);
    }

    void acc(int x) {
        for (int y = 0; x;) {
            splay(x);
            tree[x].mval.vup(tree[rc(x)].mval);
            rc(x) = y;
            tree[x].mval.rv(tree[rc(x)].mval);
            pull(x);
            y = x;
            x = fa(x);
        }
    }

    void mrk(int x) {
        acc(x);
        splay(x);
        tree[x].mval.reve();
        tree[x].tag ^= 1;
    }

    //x变为原树的根，y变成辅助树的根
    const Info &split(int x, int y) {
        mrk(x);
        acc(y);
        splay(y);
        return tree[y].mval;
    }

    int find(int x) {
        acc(x);
        splay(x);
        while (lc (x))
            push(x), x = lc(x);
        splay(x);
        return x;
    }

    void link(int x, int y) {
        mrk(x);
        mrk(y);
        if (find(y) != x) {
            fa(x) = y;
            tree[y].mval.vup(tree[x].mval);
        } 
    }

    void cut(int x, int y) {
        mrk(x);
        if (find(y) == x
            && fa(y) == x && !lc(y)) {
            rc(x) = fa(y) = 0;
            pull(x);
        }
    }

    void modify(int x, const Info &val) {
        mrk(x);
        tree[x].mval.modify(val);
        pull(x);
    }

    bool same(int x, int y) {
        mrk(x);
        return find(y) == x;
    }
    node &operator[](int x) {
        return tree[x];
    }
    void dfs(int u) {
        auto dfs = [&] (auto &&dfs, int u, int fa, int from) -> void {
            // push(u);
            for (auto i : {0, 1}) {
                if (i == 1) {
                    cerr << '(' << fa << " [" << from << ']' << " -> "  << u << ')' << ' ';
                    debug(tree[u].s[0], tree[u].s[1]);
                    tree[u].mval.show();
                }
                if (tree[u].s[i]) {
                    dfs(dfs, tree[u].s[i], u, i);
                }
            }
        };
        dfs(dfs, u, u, 0);
    }
};

struct Info {
    void reve() {}
    void modify(const Info& rhs) {}
    void vup(const Info &rhs) {}
    void rv(const Info &rhs) {}
    void up(const Info &lhs, const Info &rhs) {}
    void clear() {}
    void show() {}
};

using Tree = linkCutTree<Info>;
```

## RMQ

### catTree

```cpp
template<typename T, class F = function<T(T, T)>>
struct catTree {
    static constexpr int B = 24;
    int n;
    array<vector<T>, B> a;
    F merge;
    catTree() {}
    catTree(const vector<T> &_init, F merge) {
        init(_init, merge);
    }
    void init(const vector<T> &_init, F merge) {
        this->merge = merge;
        n = _init.size();
        a[0] = _init;
        for (int k = 1, w = 4; k <= __lg(n); k += 1, w <<= 1) {
            a[k].assign(n, {});
            for (int l = 0, mid = w / 2, r = std::min(w, n); 
                    mid < n; 
                        l = r, mid += w, r = std::min(r + w, n)) {
                a[k][mid - 1] = a[0][mid - 1];
                for (int i = mid - 2; i >= l; i -= 1) {
                    a[k][i] = merge(a[0][i], a[k][i + 1]);
                }
                a[k][mid] = a[0][mid];
                for (int i = mid + 1; i < r; i += 1) {
                    a[k][i] = merge(a[0][i], a[k][i - 1]);
                }
            }
        }
    }
    T operator() (int l, int r) {
        if (r - l == 1) {
            return a[0][l];
        }
        int k = __lg(l ^ (r - 1));
        return merge(a[k][l], a[k][r - 1]);
    }
};
```

### 状压rmq

```cpp
/**
 * author:jiangly 
 * pretreatment:O(n)
 * Inquire:O(1) 
*/
template<class T,
    class Cmp = std::less<T>>
struct RMQ {
    const Cmp cmp = Cmp();
    static constexpr unsigned B = 64;
    using u64 = unsigned long long;
    int n;
    std::vector<std::vector<T>> a;
    std::vector<T> pre, suf, ini;
    std::vector<u64> stk;
    RMQ() {}
    RMQ(const std::vector<T> &v) {
        init(v);
    }
    void init(const std::vector<T> &v) {
        n = v.size();
        pre = suf = ini = v;
        stk.resize(n);
        if (!n) {
            return;
        }
        const int M = (n - 1) / B + 1;
        const int lg = std::__lg(M);
        a.assign(lg + 1, std::vector<T>(M));
        for (int i = 0; i < M; i++) {
            a[0][i] = v[i * B];
            for (int j = 1; j < B && i * B + j < n; j++) {
                a[0][i] = std::min(a[0][i], v[i * B + j], cmp);
            }
        }
        for (int i = 1; i < n; i++) {
            if (i % B) {
                pre[i] = std::min(pre[i], pre[i - 1], cmp);
            }
        }
        for (int i = n - 2; i >= 0; i--) {
            if (i % B != B - 1) {
                suf[i] = std::min(suf[i], suf[i + 1], cmp);
            }
        }
        for (int j = 0; j < lg; j++) {
            for (int i = 0; i + (2 << j) <= M; i++) {
                a[j + 1][i] = std::min(a[j][i], a[j][i + (1 << j)], cmp);
            }
        }
        for (int i = 0; i < M; i++) {
            const int l = i * B;
            const int r = std::min(1U * n, l + B);
            u64 s = 0;
            for (int j = l; j < r; j++) {
                while (s && cmp(v[j], v[std::__lg(s) + l])) {
                    s ^= 1ULL << std::__lg(s);
                }
                s |= 1ULL << (j - l);
                stk[j] = s;
            } 
        } 
    } 
    T operator()(int l, int r) {
        if (l / B != (r - 1) / B) {
            T ans = std::min(suf[l], pre[r - 1], cmp);
            l = l / B + 1;
            r = r / B;
            if (l < r) {
                int k = std::__lg(r - l);
                ans = std::min({ans, a[k][l], a[k][r - (1 << k)]}, cmp);
            }
            return ans;
        } else {
            int x = B * (l / B);
            return ini[__builtin_ctzll(stk[r - 1] >> (l - x)) + l];
        }
    }
};

```

### ST表

```cpp
template<typename T, class F = function<T(T, T)>>
struct SparseTable {
    int n; 
    constexpr static int B = 24;
    array<vector<T>, B> a;
    F merge;
    SparseTable() {}
    SparseTable(const vector<T> &info, F merge) {
        init(info, merge);
    }
    void init(const vector<T> &info, F merge) {
        this->merge = merge;
        n = info.size();
        for (int i = 0; i < B; i += 1) {
            a[i].assign(n, {});
        }
        a[0] = info;
        for (int k = 1; k <= __lg(n); k += 1) {
            for (int i = n - (1 << k); i >= 0; i -= 1) {
                a[k][i] = merge(a[k - 1][i], a[k - 1][i + (1 << k - 1)]);
            }
        }
    }
    T operator() (int l, int r) {
        int k = __lg(r - l);
        return merge(a[k][l], a[k][r - (1 << k)]);
    }
};

```

## 并查集

### 标准

```cpp
struct DSU {
    std::vector<int> f, siz;
    
    DSU() {}
    DSU(int n) {
        init(n);
    }
    
    void init(int n) {
        f.resize(n);
        std::iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }
    
    int find(int x) {
        while (x != f[x]) {
            x = f[x] = f[f[x]];
        }
        return x;
    }
    
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    
    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;
        return true;
    }
    
    int size(int x) {
        return siz[find(x)];
    }
};


```

### 可持久化

```cpp
struct PDSU {
    int n;
    struct node;
    using Tp = Base<node>;
    struct node {
        int f, siz;
        Tp ch[2];
    };
    Tp news() {
        Tp t = Tp::news();
        return t;
    }
    vector<Tp> root;
    PDSU(): n(0) {} 
    PDSU(int _n, int _m = 0) {
        init(_n, _m);
    }
    void build(Tp t, int l, int r) {
        if (r - l == 1) {
            t->f = l;
            t->siz = 1;
            return;
        }
        int m = (l + r) / 2;
        t->ch[0] = news(), t->ch[1] = news();
        build(t->ch[0], l, m), build(t->ch[1], m, r);
    }
    void init(int _n, int m = 0) {
        n = _n;
        root.reserve(m + 1);
        root.push_back(news());
        build(root.back(), 0, n);
    }
    void modify0(Tp &t0, Tp &t1, Tp v, int l, int r, int x) {
        if (r - l == 1) {
            t1->f = v->f;
            t1->siz = t0->siz;
            return;
        }
        int m = (l + r) >> 1;
        if (m > x) {
            t1->ch[0] = news();
            t1->ch[1] = t0->ch[1];
            modify0(t0->ch[0], t1->ch[0], v, l, m, x);
        } else {
            t1->ch[0] = t0->ch[0];
            t1->ch[1] = news();
            modify0(t0->ch[1], t1->ch[1], v, m, r, x);
        }
    }
    void modify0(int x, Tp v, Tp t0, Tp t1) {
        modify0(t0, t1, v, 0, n, x);
    }
    void modify1(Tp &t0, Tp &t1, Tp v, int l, int r, int x) {
        if (r - l == 1) {
            t1->f = t0->f;
            t1->siz = t0->siz + v->siz;
            return;
        }
        int m = (l + r) >> 1;
        if (m > x) {
            t1->ch[0] = news();
            t1->ch[1] = t0->ch[1];
            modify1(t0->ch[0], t1->ch[0], v, l, m, x);
        } else {
            t1->ch[0] = t0->ch[0];
            t1->ch[1] = news();
            modify1(t0->ch[1], t1->ch[1], v, m, r, x);
        }
    }
    void modify1(int x, Tp v, Tp t0, Tp t1) {
        modify1(t0, t1, v, 0, n, x);
    }
    void dfs(Tp t, int l, int r) {
        if (r - l == 1) {
            cerr << "(" << t->f << ", " << t->siz << "), ";
            return;
        }
        int m = (l + r) >> 1;
        dfs(t->ch[0], l, m);
        dfs(t->ch[1], m, r);
    }
    void dfs(int time) {
        dfs(root[time], 0, n);
        cerr << endl;
    }
    Tp Query(Tp t, int l, int r, int x) {
        while (r - l != 1) {
            int m = (l + r) / 2;
            if (m > x) 
                t = t->ch[0], r = m;
            else 
                t = t->ch[1], l = m;
        }
        return t;
    }
    Tp Query(int x, Tp t) {
        return Query(t, 0, n, x);
    }
    Tp find(int x, Tp t) {
        Tp fa = Query(x, t);
        return fa->f == x ? 
            fa : find(fa->f, t);
    }
    bool same(int u, int v, int t = -1) {
        t = t == -1 ? int(root.size()) - 1 : t;
        root.push_back(root[t]);
        Tp lhs = find(u, root[t]), rhs = find(v, root[t]);
        return lhs->f == rhs->f;
    }
    void merge(int u, int v, int t = -1) {
        t = t == -1 ? int(root.size()) - 1 : t;
        Tp lhs = find(u, root[t]), rhs = find(v, root[t]);
        if (lhs->f == rhs->f) {
            root.push_back(root[t]);
            return;
        }
        if (lhs->siz < rhs->siz) {
            swap(lhs, rhs);
        }
        Tp cur0 = news();
        modify0(rhs->f, lhs, root[t], cur0);
        Tp cur1 = news();
        modify1(lhs->f, rhs, cur0, cur1);
        root.push_back(cur1);
    }
    void roll(int t) {
        root.push_back(root[t]);
    }
};
using DSU = PDSU;
```

### 可撤回

```cpp
struct DSU {
    vector<int> fa, siz;
    vector<array<int, 4>> h;
    vector<i64> lazy;

    DSU() {}

    DSU(int n) {
        init(n);
    }

    void init(int n) {
        fa.resize(n);
        iota(fa.begin(), fa.end(), 0);
        siz.assign(n, 1);
        lazy.assign(n, 0);
    }

    int find(int x) {
        while (x != fa[x]) {
            x = fa[x];
        }
        return x;
    }

    int size(int x) {
        return siz[find(x)];
    }

    bool same(int u, int v) {
        return find(u) == find(v);
    }

    void merge(int u, int v) {
        int x = find(u);
        int y = find(v);
        if (x == y) return;
        if (siz[x] < siz[y]) std::swap(x, y);
        h.push_back({x, y, siz[x], fa[y]});
        siz[x] = siz[x] + siz[y];
        fa[y] = x;
        int p = y;
        lazy[y] -= lazy[x];
    }

    int clock() {
        return h.size();
    }

    void roll(int to) {
        while (h.size() > to) {
            auto [u, v, sizu, fav] = h.back();
            siz[u] = sizu;
            fa[v] = fav;
            h.pop_back();
            lazy[v] += lazy[u];
        }
    }
};
```

## 平衡树

### set

#### FHQtreap

```cpp
/**
 * FHQ_treap set卡常:
 * 1.递归改非递归       o
 * 2.insert split优化   o
 */
# include <ext/random>
__gnu_cxx::sfmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

template<typename Info>
struct FHQ_treap {
    struct Node;
    using Tp = Base<Node>;
    struct Node {
        Tp ch[2];
        Info val;
        int siz, key;
    };

    Tp root;

    void pull(Tp t) {
        t->siz = t->ch[0]->siz + 1 + t->ch[1]->siz;
    }
    // by val
    pair<Tp, Tp> split(Tp t, Info val) {
        if (!t) {
            return {t, t};
        }
        Tp ohs;
        if (t->val < val) {
            tie(t->ch[1], ohs) = split(t->ch[1], val);
            pull(t);
            return {t, ohs};
        } else {
            tie(ohs, t->ch[0]) = split(t->ch[0], val);
            pull(t);
            return {ohs, t};
        }
    }

    Tp merge(Tp u, Tp v) {
        if (!u | !v) return u.x | v.x;
        if (u->key < v->key) {
            u->ch[1] = merge(u->ch[1], v);
            pull(u);
            return u;
        } else {
            v->ch[0] = merge(u, v->ch[0]);
            pull(v);
            return v;
        }
    }

// set operator
    void insert(Tp &t, Tp v) {
        if (!t) {
            t = v;
            // ps;
            return;
        }
        if (t->key < v->key) {
            tie(v->ch[0], v->ch[1]) = split(t, v->val);
            t = v;
            pull(t);
            return;
        }
        t->siz += 1;
        insert(t->ch[v->val > t->val || 
            (t->val == v->val && int(rng()) >= 0)], v);
        pull(t);
    }

    void insert(Info v) {
        Tp t = Tp::__new();
        t->key = rng();
        t->val = v;
        t->siz = 1;
        insert(root, t);
    }

    void erase(Tp &t, Info v) {
        if (t->val == v) {
            t = merge(t->ch[0], t->ch[1]);
            return;
        } else {
            // t->siz -= 1;
            erase(t->ch[v > t->val], v);
            pull(t);
        }
    }

    void erase(Info v) {
        erase(root, v);
    }
    // by val
    int less(Info v) {
        Tp t = root;
        int less_siz = 0;
        while (t) {
            if (t->val >= v) {
                t = t->ch[0];
            } else {
                less_siz += t->ch[0]->siz + 1;
                t = t->ch[1];
            }
        }
        return less_siz;
    }
    // from zero
    Tp rank(Tp t, int k) {
        k += 1;
        while (true) {
            if (t->ch[0]->siz >= k) {
                t = t->ch[0];
            } else if (t->ch[0]->siz + 1 < k) {
                k -= t->ch[0]->siz + 1;
                t = t->ch[1];
            } else
                break;
        }
        return t;
    }
    // from zero
    Tp operator[] (int k) {
        return rank(root, k);
    }
    // by val
    static constexpr int inf = std::numeric_limits<int>::max();
    Info prev(Info v) {
        Tp t = root, p;
        while (t) {
            if (t->val < v) {
                p = t;
                t = t->ch[1];
            } else {
                t = t->ch[0];
            }
        }
        return p ? p->val : -inf;
    }
    // by val
    Info next(Info v) {
        Tp t = root, p;
        while (t) {
            if (t->val <= v) {
                t = t->ch[1];
            } else {
                p = t;
                t = t->ch[0];
            }
        }
        return p ? p->val : inf;
    }
    void dfs(Tp t, int dep = 0) {
        if (!t) {
            return;
        }
        dfs(t->ch[0], dep + 1);
        for (int i = 0; i < dep; i += 1) cerr << '\t';
        cerr << t->val << ' ' << t->key << '\n';
        dfs(t->ch[1], dep + 1);
    }
    void dfs() {return dfs(root);}
};
```

#### 替罪羊树

```cpp
constexpr double alpha = 0.75;
template<typename Info>
struct scapegoat_tree {
    struct node;
    using Tp = Base<node>;
    struct node {
        Tp ch[2];
        Info val;
        int siz, fac;
        bool exist;
    };

    Tp root = 0;

    Tp __new() {
        return Tp::__new();
    }

    void reset(Tp &t) {
        t->siz = t->fac = 1;
        t->exist = true;
        t->ch[0] = t->ch[1] = 0;
    }

    void reset(Tp &t, Info val) {
        t->siz = t->fac = 1;
        t->exist = true;
        t->ch[0] = t->ch[1] = 0;
        t->val = val;
    }

    Tp __new(Info val) {
        Tp t = __new();
        reset(t, val);
        return t;
    }

    scapegoat_tree() {}

    bool imbalance(Tp t) {
        return max({t->ch[0]->siz, t->ch[1]->siz}) 
                    > t->siz * alpha 
        || t->siz * alpha > t->fac;
    }

    vector<Tp> v;
    void collect(Tp t) {
        if (!t) return;
        collect(t->ch[0]);
        if (t->exist)
            v.push_back(t);
        collect(t->ch[1]);
    }
    void pull(Tp t) {
        t->siz = t->ch[0]->siz + 1 + t->ch[1]->siz;
        t->fac = t->ch[0]->fac + t->exist + t->ch[1]->fac;
    }
    void lift(int l, int r, Tp &t) {
        if (l == r) {
            t = v[l];
            reset(t);
            return;
        }
        int m = l + r >> 1;
        while (l < m && v[m]->val == v[m - 1]->val) {
            -- m;
        }
        t = v[m];
        if (l != m) lift(l, m - 1, t->ch[0]);
        else t->ch[0] = 0;
        lift(m + 1, r, t->ch[1]);
        pull(t);
    }
    void rebuild(Tp &t) {
        v.clear();
        collect(t);
        if (v.empty()) {
            t = 0;
            return;
        }
        lift(0, v.size() - 1, t);
    }

    void check(Tp &t, Tp E) {
        if (t == E) return;
        if (imbalance(t)) {
            rebuild(t);
            return;
        }
        check(t->ch[E->val >= t->val], E);
    }

    void insert(Tp &t, Info val) {
        if (!t) {
            t = __new(val);
            // dfs();
            check(root, t);
            return;
        }
        t->siz ++;
        t->fac ++;
        insert(t->ch[val >= t->val], val);
    }
    void insert(Info val) {
        insert(root, val);
    }
    void erase(Tp &t, Info val) {
        if (t->exist && t->val == val) {
            t->exist = false;
            t->fac --;
            check(root, t);
            return;
        }
        t->fac--;
        erase(t->ch[val >= t->val], val);
    }
    void erase(Info val) {
        erase(root, val);
    }
    int less(Info val) {
        Tp t = root;
        int less = 0;
        while (t) {
            if (val <= t->val) {
                t = t->ch[0];
            } else {
                less += t->exist + t->ch[0]->fac;
                t = t->ch[1];
            }
        }
        return less;
    }
    // from zero
    Tp operator[](int k) {
        k += 1;
        Tp t = root;
        while (t) {
            if (t->ch[0]->fac >= k) {
                t = t->ch[0];
            } else if (t->ch[0]->fac + t->exist < k) {
                k -= t->ch[0]->fac + t->exist;
                t = t->ch[1];
            } else 
                break;
        }
        return t;
    }
    void dfs(Tp t, int dep = 0) {
        if (!t) return;
        dfs(t->ch[0], dep + 1);
        for (int i = 0; i < dep; i += 1) cerr << '\t';
        cerr << t->val << ' ' << t->siz << ' ' << t->fac << endl;
        dfs(t->ch[1], dep + 1);
    }
    void dfs() { return dfs(root); }
}; //scapegoat_tree

using scet = scapegoat_tree<int>;
```

### 区间操作

#### FHQtreap

```cpp
# include <ext/random>
__gnu_cxx::sfmt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());

struct node;
using Tp = Base<node>;

struct node {
    Tp ch[2];
    int siz, k;
    i64 val;
    i64 tag;
};

Tp news() {
    Tp t = Tp::news();
    t->k = rng();
    return t;
}

Tp news(auto val) {
    Tp t = news();
    t->val = val;
    t->siz = 1;
    t->tag = 0;
    return t;
}

void ap(Tp t, auto tag) {
    if (t) {
        t->val += tag;
        t->tag += tag;
    }
}

void push(Tp t) {
    if (t->tag) {
        ap(t->ch[0], t->tag);
        ap(t->ch[1], t->tag);
        t->tag = 0;
    }
}

void pull(Tp t) {
    t->siz = t->ch[0]->siz + 1 + t->ch[1]->siz;
}

// to [-inf, val) and [val, inf]
pair<Tp, Tp> split1(Tp t, auto val) {
    if (!t) {
        return {t, t};
    }
    push(t);
    Tp u;
    if (t->val < val) {
        tie(t->ch[1], u) = split1(t->ch[1], val);
        pull(t);
        return {t, u};
    } else {
        tie(u, t->ch[0]) = split1(t->ch[0], val);
        pull(t);
        return {u, t};
    }
}


// to [1, rk) and [rk, n]
pair<Tp, Tp> split2(Tp t, int rk) {
    if (!t) {
        return {t, t};
    }
    push(t);
    Tp u;
    if (rk <= t->ch[0]->siz) {
        tie(u, t->ch[0]) = split2(t->ch[0], rk);
        pull(t);
        return {u, t};
    } else if (rk > t->ch[0]->siz + 1) {
        tie(t->ch[1], u) = split2(t->ch[1], rk - 1 - t->ch[0]->siz);
        pull(t);
        return {t, u};
    } else {
        u = t->ch[0];
        t->ch[0] = 0;
        pull(t);
        return {u, t};
    }
}

Tp merge(Tp u, Tp v) {
    if (!u | !v) return u.x | v.x;
    if (u->k < v->k) {
        push(u);
        u->ch[1] = merge(u->ch[1], v);
        pull(u);
        return u;
    } else {
        push(v);
        v->ch[0] = merge(u, v->ch[0]);
        pull(v);
        return v;
    }
}

// 2056

void dfs(Tp t, int dep = 0) {
    if (!t) {
        return;
    }
    dfs(t->ch[0], dep + 1);
    for (int i = 0; i < dep; i += 1) cerr << '\t';
    cerr << t->val << ' ' << t->tag << '\n';
    dfs(t->ch[1], dep + 1);
}

// less_to_val_siz
int less_to_val(Tp t, auto val) {
    int less_siz = 0;
    while (t) {
        push(t);
        if (t->val >= val) {
            t = t->ch[0];
        } else {
            less_siz += t->ch[0]->siz + 1;
            t = t->ch[1];
        }
    }
    return less_siz;
}


Tp rank(Tp t, int rk) {
    while (true) {
        push(t);
        if (t->ch[0]->siz >= rk) {
            t = t->ch[0];
        } else if (t->ch[0]->siz + 1 < rk) {
            rk -= t->ch[0]->siz + 1;
            t = t->ch[1];
        } else
            break;
    }
    return t;
}

// prev_to_val
Tp prev(Tp t, auto val) {
    Tp p;
    while (t) {
        push(t);
        if (t->val < val) {
            p = t;
            t = t->ch[1];
        } else {
            t = t->ch[0];
        }
    }
    return p;
}
// next_to_val
Tp next(Tp t, auto val) {
    Tp p;
    while (t) {
        push(t);
        if (t->val <= val) {
            t = t->ch[1];
        } else {
            p = t;
            t = t->ch[0];
        }
    }
    return p;
}

```

#### 可持久化

```cpp
# include <ext/random>
__gnu_cxx::sfmt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());

struct node;
using Tp = Base<node>;

struct node {
    Tp ch[2];
    int siz, k;
    i64 val;
    i64 tag;
};

Tp news() {
    Tp t = Tp::news();
    t->k = rng();
    return t;
}

Tp news(Tp u) {
    if (!u) {
        return u;
    }
    Tp p = Tp::news();
    *p = *u;
    return p;
}

void ap(Tp t, auto tag) {
    if (!t) {
        return;
    }
    t->val += tag;
    t->tag += tag;
}

void push(Tp t) {
    if (t->tag) {
        t->ch[0] = news(t->ch[0]);
        t->ch[1] = news(t->ch[1]);
        ap(t->ch[0], t->tag);
        ap(t->ch[1], t->tag);
        t->tag = decltype(t->tag)();
    }
}

void pull(Tp t) {
    t->siz = t->ch[0]->siz + 1 + t->ch[1]->siz;
}


pair<Tp, Tp> split1(Tp &t, auto val) {
    if (!t) {
        return {0, 0};
    }
    t = news(t);
    push(t);
    Tp u;
    if (t->val < val) {
        tie(t->ch[1], u) = split1(t->ch[1], val);
        pull(t);
        return {t, u};
    } else {
        tie(u, t->ch[0]) = split1(t->ch[0], val);
        pull(t);
        return {u, t};
    }
}

pair<Tp, Tp> split2(Tp t, int rk) {
    if (!t) {
        return {t, t};
    }
    push(t);
    t = news(t);
    Tp u;
    if (rk <= t->ch[0]->siz) {
        tie(u, t->ch[0]) = split2(t->ch[0], rk);
        pull(t);
        return {u, t};
    } else {
        tie(t->ch[1], u) = split2(t->ch[1], rk - 1 - t->ch[0]->siz);
        pull(t);
        return {t, u};
    }
}

template<bool isNew = false>
Tp merge(Tp u, Tp v) {
    if (!u | !v) return u.x | v.x;
    if (u->key < v->key) {
        push(u);
        if (isNew) {
            u = __new(u);
        }
        u->ch[1] = merge<isNew>(u->ch[1], v);
        pull(u);
        return u;
    } else {
        push(v);
        if (isNew) {
            v = __new(v);
        }
        v->ch[0] = merge<isNew>(u, v->ch[0]);
        pull(v);
        return v;
    }
}
```

### 参考旧版

#### FHQtreap

```cpp
/**
 * FHQ_treap 卡常:
 * 1.递归改非递归       x
 * 2.insert split优化   o
 * 3.build 优化         o
 */

__gnu_cxx::sfmt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());

template<typename Info, typename Tag>
struct FHQ_treap {
    struct Node;
    using Tp = u32_p<Node>;
    
    using T = typename Info::T;
    struct Node {
        Tp ch[2];
        Info info;
        int key;
        Tag tag;
        bool rev;
    };
    
    Tp __new() {
        Tp t = Tp::__new();
        t->key = rng();
        return t;
    }

    void apply(Tp t, const Tag &tag) {
        if (t) {
            t->info.apply(tag);
            t->tag.apply(tag);
        }
    }

    void push(Tp t) {
        if (t->rev) {
            swap(t->ch[0], t->ch[1]);
            t->ch[0]->rev ^= 1;
            t->ch[0]->info.reve();
            t->ch[1]->rev ^= 1;
            t->ch[1]->info.reve();
            t->rev = 0;
        }
        if (t->tag) {
            apply(t->ch[0], t->tag);
            apply(t->ch[1], t->tag);
            t->tag = Tag();
        }
    }

    void pull(Tp t) {
        t->info.up(t->ch[0]->info, t->ch[1]->info);
    }

    pair<Tp, Tp> split_by_val(Tp t, T val) {
        if (!t) {
            return {t, t};
        }
        // push(t);
        Tp ohs;
        if (t->info.val < val) {
            tie(t->ch[1], ohs) = split_by_val(t->ch[1], val);
            pull(t);
            return {t, ohs};
        } else {
            tie(ohs, t->ch[0]) = split_by_val(t->ch[0], val);
            pull(t);
            return {ohs, t};
        }
    }
    
    pair<Tp, Tp> split_by_rank(Tp t, int rank) {
        if (!t) {
            return {t, t};
        }
        push(t);
        Tp ohs;
        if (rank <= t->ch[0]->info.siz) {
            tie(ohs, t->ch[0]) = split_by_rank(t->ch[0], rank);
            pull(t);
            return {ohs, t};
        } else if (rank > t->ch[0]->info.siz + 1) {
            tie(t->ch[1], ohs) = split_by_rank(t->ch[1], rank - 1 - t->ch[0]->info.siz);
            pull(t);
            return {t, ohs};
        } else {
            ohs = t->ch[0];
            t->ch[0] = 0;
            pull(t);
            return {ohs, t};
        }
    }

    Tp merge(Tp u, Tp v) {
        if (!u | !v) return u.x | v.x;
        if (u->key < v->key) {
            push(u);
            u->ch[1] = merge(u->ch[1], v);
            pull(u);
            return u;
        } else {
            push(v);
            v->ch[0] = merge(u, v->ch[0]);
            pull(v);
            return v;
        }
    }

    void rangeReverse(Tp &t, int x, int y) {
        // debug(x, y);
        auto [tmp, r] = split_by_rank(t, y);
        auto [l, m] = split_by_rank(tmp, x);
        m->rev ^= 1;
        m->info.reve();
        t = merge(l, merge(m, r));
    }

    void rangeApply(Tp &t, int x, int y, const Tag &tag) {
        auto [tmp, r] = split_by_rank(t, y);
        auto [l, m] = split_by_rank(tmp, x);
        apply(m, tag);
        t = merge(l, merge(m, r));
    }

    Tp build(int l, int r) {
        if (r - l == 1) {
            Tp t = __new();
            t->info.init(l);
            return t;
        }
        int m = l + r >> 1;
        return merge(build(l, m), build(m, r));
    }

    
    void insert(Tp &t, Tp v) {
        if (!t) {
            t = v;
            return;
        }
        if (t->key < v->key) {
            tie(v->ch[0], v->ch[1]) = split_by_val(t, v->info.val);
            t = v;
            pull(t);
            return;
        }
        // t->info.siz += 1;
        insert(t->ch[v->info.val > t->info.val || 
            (t->info.val == v->info.val && int(rng()) >= 0)], v);
        pull(t);
    }

    void erase(Tp &t, T v) {
        if (t->info.val == v) {
            t = merge(t->ch[0], t->ch[1]);
            return;
        } else {
            // t->info.siz -= 1;
            erase(t->ch[v > t->info.val], v);
            pull(t);
        }
    }

    int less_to_val(Tp t, Info val) {
        int less_siz = 0;
        while (t) {
            if (t->info.val >= val.val) {
                t = t->ch[0];
            } else {
                less_siz += t->ch[0]->info.siz + 1;
                t = t->ch[1];
            }
        }
        return less_siz;
    }
    Tp rank(Tp t, int rank) {
        while (true) {
            if (t->ch[0]->info.siz >= rank) {
                t = t->ch[0];
            } else if (t->ch[0]->info.siz + 1 < rank) {
                rank -= t->ch[0]->info.siz + 1;
                t = t->ch[1];
            } else
                break;
        }
        return t;
    }
    Tp prev_to_val(Tp t, Info val) {
        Tp p;
        while (t) {
            if (t->info.val < val.val) {
                p = t;
                t = t->ch[1];
            } else {
                t = t->ch[0];
            }
        }
        return p;
    }
    Tp next_to_val(Tp t, Info val) {
        Tp p;
        while (t) {
            if (t->info.val <= val.val) {
                t = t->ch[1];
            } else {
                p = t;
                t = t->ch[0];
            }
        }
        return p;
    }
    void dfs(Tp t, int dep = 0) {
        if (!t) {
            return;
        }
        push(t);
        dfs(t->ch[0], dep + 1);
        cout << t->info.val << ' ';
        // for (int i = 0; i < dep; i += 1) cerr << '\t';
        // cerr << t->info << ' ' << t->key << ' ' << t->rev << '\n';
        dfs(t->ch[1], dep + 1);
    }
};

struct Tag {
    constexpr operator bool() {
        return false;
    }
    void apply(const Tag &t) {}
};
struct Info {
    using T = int;
    int val, siz;
    void reve() {}
    void up(const Info &lhs, const Info &rhs) {
        siz = lhs.siz + 1 + rhs.siz;
    }
    void init(int val) {
        this->val = val;
        siz = 1;
    }
    void apply(const Tag &t) {}
    friend ostream &operator<<(ostream &cout, Info rhs) {
        return cout << "Info: " << rhs.val << ' ' << rhs.siz;
    }
};


using treap = FHQ_treap<Info, Tag>;
using Tp = treap::Tp;
treap T;

```

#### splay

```cpp
constexpr int max_size = 262144000;
uint8_t buf[max_size];
uint8_t *head = buf;

using u32 = uint32_t;

template <class T>
struct u32_p {
    u32 x;
    u32_p(u32 x = 0) : x(x) {}
    T *operator->() {
        return (T *)(buf + x);
    }
    operator bool() {
        return x;
    }
    operator u32() {
        return x;
    }
    bool operator==(u32_p rhs) const {
        return x == rhs.x;
    }
    static u32_p __new() {
        // assert(x < max_size);
        return (head += sizeof(T)) - buf;
    }
};

template<class Info, class Tag>
struct Balance_Tree {
    struct Tree;
    using Tp = u32_p<Tree>;
    
    struct Tree {
        Tp ch[2], p;
        Info info;
        bool rev;
        Tag tag;
    };

    // build operator
    Balance_Tree() {
        Tp()->info.Null();
    }
    Tp __new () {
        return Tp::__new();
    }

    Tp build (int l, int r) {
        if (l > r) return 0;
        int m = l + r >> 1;
        Tp p = __new();
        p->ch[0] = build(l, m - 1);
        if (p->ch[0]) p->ch[0]->p = p;
        {
            // fun
        }
        p->ch[1] = build(m + 1, r);
        if (p->ch[1]) p->ch[1]->p = p;
        pull(p);
        return p;
    }
    template<typename F>
    Tp build (int l, int r, F fun) {
        if (l > r) return 0;
        int m = l + r >> 1;
        Tp p = __new();
        p->ch[0] = build(l, m - 1, fun);
        if (p->ch[0]) p->ch[0]->p = p;
        fun(p, m);
        p->ch[1] = build(m + 1, r, fun);
        if (p->ch[1]) p->ch[1]->p = p;
        pull(p);
        return p;
    }
    // build operator

    // basic operator
    bool pos(Tp t) {
        return t->p->ch[1] == t;
    }

    void apply(Tp t, const Tag &v) {
        if (t) {
            t->info.apply(v);
            t->tag.apply(v);
        }
    }

    void push(Tp t) {
        if (t->rev) {
            t->ch[0]->rev ^= 1;
            t->ch[1]->rev ^= 1;
            swap(t->ch[0], t->ch[1]);
            t->rev = 0;
        }
        if (t->tag) {
            apply(t->ch[0], t->tag);
            apply(t->ch[1], t->tag);
            t->tag = Tag();
        }
    }

    void pull(Tp t) {
        t->info.up(t->ch[0]->info, t->ch[1]->info);
    }

    void rotate(Tp t) {
        Tp q = t->p;
        int x = !pos(t);
        q->ch[!x] = t->ch[x];
        if (t->ch[x]) t->ch[x]->p = q;
        t->p = q->p;
        if (q->p) q->p->ch[pos(q)] = t;
        t->ch[x] = q;
        q->p = t;
        pull(q);
    }

    void pushall(Tp t) {
        if (t->p) pushall(t->p);
        push(t);
    }

    void splay(Tp t, Tp top = 0) {
        pushall(t);
        while (t->p != top) {               
            if (t->p->p != top)
                rotate(pos(t) ^ pos(t->p) ? t : t->p);
            rotate(t);
        }
        pull(t);
    }
    // basic operator

    // shrink operator
    Tp rank(Tp &t, int k) {
        int mid = k;
        while (true) {
            push(t);
            if (k > t->ch[0]->info.siz + t->info.rep_cnt) {
                k -= t->ch[0]->info.siz + t->info.rep_cnt;
                t = t->ch[1];
            } else if (k <= t->ch[0]->info.siz) {
                t = t->ch[0];
            } else break;
        }
        splay(t);
        return t;
    }

    template<bool isRight>
    void split_by_range(Tp &t, int k) { // split range, but not really split
        rank(t, k);
        if constexpr(!isRight) {
            if (k > t->info.l) {
                Tp l = __new();
                (l->ch[0] = t->ch[0])->p = l;
                (l->p = t)->ch[0] = l;
                l->info.init(t->info.l, k - 1, t->info);
                t->info.init(k, t->info.r, t->info);
                pull(l), pull(t);
            }
        } else {
            if (k < t->info.r) {
                Tp r = __new();
                (r->ch[1] = t->ch[1])->p = r;
                (r->p = t)->ch[1] = r;
                r->info.init(k + 1, t->info.r, t->info);
                t->info.init(t->info.l, k, t->info);
                pull(r), pull(t);
            }
        }
    }

    Tp shrink_by_split_range(Tp &t, int l, int r) {
        if (r == t->info.siz && l == 1) {
            return t;
        } else if (r == t->info.siz) {
            split_by_range<1>(t, l - 1);
            return t->ch[1];
        } else if (l == 1) {
            split_by_range<0>(t, r + 1);
            return t->ch[0];
        } else {
            split_by_range<1>(t, l - 1);
            Tp lhs = t;
            split_by_range<0>(t, r + 1);
            splay(lhs, t);
            return lhs->ch[1];
        }
    }

    Tp shrink(Tp &t, int l, int r) {
        if (r == t->info.siz && l == 1) {
            return t;
        } else if (r == t->info.siz) {
            rank(t, l - 1);
            return t->ch[1];
        } else if (l == 1) {
            rank(t, r + 1);
            return t->ch[0];
        } else {
            Tp lhs = rank(t, l - 1);
            rank(t, r + 1);
            splay(lhs, t);
            return lhs->ch[1];
        }
    }

    void pullall(Tp t) {
        for (t = t->p; t; t = t->p) 
            pull(t);
    }
    // shrink operator

    // split and merge
    std::pair<Tp, Tp> split_by_val(Tp t, int x) {
        if (!t) {
            return {t, t};
        }
        Tp v = 0;
        Tp j = t;
        for (Tp i = t; i; ) {
            push(i);
            j = i;
            if (i->info >= x) {
                v = i;
                i = i->ch[0];
            } else {
                i = i->ch[1];
            }
        }
        
        splay(j);
        if (!v) {
            return {j, 0};
        }
        
        splay(v);
        
        Tp u = v->ch[0];
        if (u) {
            v->ch[0] = u->p = 0;
            pull(v);
        }
        return {u, v};
    }

    std::pair<Tp, Tp> split_by_rank(Tp t, int x) {
        if (t->info.siz < x) {
            return {t, 0};
        }

        rank(t, x);
        
        Tp u = t->ch[0];
        if (u) {
            t->ch[0] = u->p = 0;
            pull(t);
        }
        return {u, t};
    }

    Tp merge(Tp l, Tp r) {
        if (l.x * r.x == 0) {
            return l.x | r.x;
        }
        Tp i = l;
        push(i);
        for (; i->ch[1]; i = i->ch[1], push(i));
        splay(i);
        i->ch[1] = r;
        r->p = i;
        pull(i);
        return i;
    }
    // split and merge

    // set operator
    void insert(Tp &t, Tp x) {
        Tp p = 0;
        
        while (t && t->info.x != x->info.x) {
            push(t);
            p = t;
            t = t->ch[x->info.x > t->info.x];
        }

        if (!t) {
            t = x;
            t->p = p;
            if (p) p->ch[t->info.x > p->info.x] = t;
        } else {
            t->info.apply(x->info);
        }
        splay(t);
    }

    void find(Tp &t, const Info &rhs) {
        // if (!t) {
        //     return;
        // }
        while (t->info.x != rhs.x && t->ch[rhs.x > t->info.x]) {
            t = t->ch[rhs.x > t->info.x];
        }
        splay(t);
    }

    Tp prev_by_val(Tp &t, const Info &rhs) {
        Tp p;
        while (t) {
            if (t->info.x >= rhs.x) {
                t = t->ch[0];
            } else {
                p = t;
                t = t->ch[1];
            }
        }
        splay(t = p);
        return p;
    }

    Tp next_by_val(Tp &t, const Info &rhs) {
        Tp p;
        while (t) {
            if (t->info.x <= rhs.x) {
                t = t->ch[1];
            } else {
                p = t;
                t = t->ch[0];
            }
        }
        splay(t = p);
        return p;
    }

    void erase(Tp &t, const Info &rhs) {
        find(t, rhs);
        if (t->info == rhs && t->info.erase()) {
            Tp lhs = t->ch[0], rhs = t->ch[1];
            lhs->p = 0, rhs->p = 0;
            t = merge(lhs, rhs);
        }
        splay(t);
    }
    // set operator

    void dfs(Tp t, int dep = 0) {
        if (!t) {
            return;
        }
        push(t);
        dfs(t->ch[0], dep + 1);
        for (int i = 0; i < dep; i += 1) cerr << '\t';
        std::cerr << t->info << "\n";
        dfs(t->ch[1], dep + 1);
    }

};

struct Tag {
    int set = 0;
    void apply(const Tag &t) {
        set = t.set;
    }
    operator bool() {
        return set;
    }
};

struct Info {
    int x = 1, rep_cnt = 1, siz = 1;
    int l = 0, r = 0;
    int sum = 0;
    void up(const Info &lhs, const Info &rhs) {
        siz = lhs.siz + rep_cnt + rhs.siz;
        sum = lhs.sum + x * rep_cnt + rhs.sum;
    }
    void apply(const Tag &t) {
        x = t.set - 1;
        sum = siz * x;
    }
    void apply(const Info &t) {}
    friend ostream &operator<<(ostream &cout, Info rhs) {
        return cout << rhs.x << ' ' << rhs.rep_cnt << ' ' << rhs.siz << ' ' << rhs.l << ' ' << rhs.r << ' ' << rhs.sum;
    }
    void init(int L, int R, Info from) {
        l = L, r = R; rep_cnt = r - l + 1; x = from.x;
    }
    void Null() {}
};

using BT = Balance_Tree<Info, Tag>;
using Tp = BT::Tp;
BT tree;
```

#### treap

```cpp
constexpr int max_size = 262144000;
uint8_t buf[max_size];
uint8_t *head = buf;

using u32 = uint32_t;

template <class T>
struct u32_p {
    u32 x;
    u32_p(u32 x = 0) : x(x) {}
    T *operator->() {
        return (T *)(buf + x);
    }
    operator bool() {
        return x;
    }
    operator u32() {
        return x;
    }
    bool operator==(u32_p rhs) const {
        return x == rhs.x;
    }
    static u32_p __new() {
        // assert(x < max_size);
        return (head += sizeof(T)) - buf;
    }
};


/**
 * FHQ_treap 卡常:
 * 1.递归改非递归       x
 * 2.insert split优化   o
 * 3.build 优化         o
 */

__gnu_cxx::sfmt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());

template<typename Info, typename Tag>
struct FHQ_treap {
    struct Node;
    using Tp = u32_p<Node>;
    
    using T = typename Info::T;
    struct Node {
        Tp ch[2];
        Info info;
        int key;
        Tag tag;
        bool rev;
    };
    
    Tp __new() {
        Tp t = Tp::__new();
        t->key = rng();
        return t;
    }

    void apply(Tp t, const Tag &tag) {
        if (t) {
            t->info.apply(tag);
            t->tag.apply(tag);
        }
    }

    void push(Tp t) {
        if (t->rev) {
            swap(t->ch[0], t->ch[1]);
            t->ch[0]->rev ^= 1;
            t->ch[0]->info.reve();
            t->ch[1]->rev ^= 1;
            t->ch[1]->info.reve();
            t->rev = 0;
        }
        if (t->tag) {
            apply(t->ch[0], t->tag);
            apply(t->ch[1], t->tag);
            t->tag = Tag();
        }
    }

    void pull(Tp t) {
        t->info.up(t->ch[0]->info, t->ch[1]->info);
    }

    pair<Tp, Tp> split_by_val(Tp t, T val) {
        if (!t) {
            return {t, t};
        }
        // push(t);
        Tp ohs;
        if (t->info.val < val) {
            tie(t->ch[1], ohs) = split_by_val(t->ch[1], val);
            pull(t);
            return {t, ohs};
        } else {
            tie(ohs, t->ch[0]) = split_by_val(t->ch[0], val);
            pull(t);
            return {ohs, t};
        }
    }
    
    pair<Tp, Tp> split_by_rank(Tp t, int rank) {
        if (!t) {
            return {t, t};
        }
        push(t);
        Tp ohs;
        if (rank <= t->ch[0]->info.siz) {
            tie(ohs, t->ch[0]) = split_by_rank(t->ch[0], rank);
            pull(t);
            return {ohs, t};
        } else if (rank > t->ch[0]->info.siz + 1) {
            tie(t->ch[1], ohs) = split_by_rank(t->ch[1], rank - 1 - t->ch[0]->info.siz);
            pull(t);
            return {t, ohs};
        } else {
            ohs = t->ch[0];
            t->ch[0] = 0;
            pull(t);
            return {ohs, t};
        }
    }

    Tp merge(Tp u, Tp v) {
        if (!u | !v) return u.x | v.x;
        if (u->key < v->key) {
            push(u);
            u->ch[1] = merge(u->ch[1], v);
            pull(u);
            return u;
        } else {
            push(v);
            v->ch[0] = merge(u, v->ch[0]);
            pull(v);
            return v;
        }
    }

    void rangeReverse(Tp &t, int x, int y) {
        // debug(x, y);
        auto [tmp, r] = split_by_rank(t, y);
        auto [l, m] = split_by_rank(tmp, x);
        m->rev ^= 1;
        m->info.reve();
        t = merge(l, merge(m, r));
    }

    void rangeApply(Tp &t, int x, int y, const Tag &tag) {
        auto [tmp, r] = split_by_rank(t, y);
        auto [l, m] = split_by_rank(tmp, x);
        apply(m, tag);
        t = merge(l, merge(m, r));
    }

    Tp build(int l, int r) {
        if (r - l == 1) {
            Tp t = __new();
            t->info.init(l);
            return t;
        }
        int m = l + r >> 1;
        return merge(build(l, m), build(m, r));
    }

    
    void insert(Tp &t, Tp v) {
        if (!t) {
            t = v;
            return;
        }
        if (t->key < v->key) {
            tie(v->ch[0], v->ch[1]) = split_by_val(t, v->info.val);
            t = v;
            pull(t);
            return;
        }
        // t->info.siz += 1;
        insert(t->ch[v->info.val > t->info.val || 
            (t->info.val == v->info.val && int(rng()) >= 0)], v);
        pull(t);
    }

    void erase(Tp &t, T v) {
        if (t->info.val == v) {
            t = merge(t->ch[0], t->ch[1]);
            return;
        } else {
            // t->info.siz -= 1;
            erase(t->ch[v > t->info.val], v);
            pull(t);
        }
    }

    int less_to_val(Tp t, Info val) {
        int less_siz = 0;
        while (t) {
            if (t->info.val >= val.val) {
                t = t->ch[0];
            } else {
                less_siz += t->ch[0]->info.siz + 1;
                t = t->ch[1];
            }
        }
        return less_siz;
    }
    Tp rank(Tp t, int rank) {
        while (true) {
            if (t->ch[0]->info.siz >= rank) {
                t = t->ch[0];
            } else if (t->ch[0]->info.siz + 1 < rank) {
                rank -= t->ch[0]->info.siz + 1;
                t = t->ch[1];
            } else
                break;
        }
        return t;
    }
    Tp prev_to_val(Tp t, Info val) {
        Tp p;
        while (t) {
            if (t->info.val < val.val) {
                p = t;
                t = t->ch[1];
            } else {
                t = t->ch[0];
            }
        }
        return p;
    }
    Tp next_to_val(Tp t, Info val) {
        Tp p;
        while (t) {
            if (t->info.val <= val.val) {
                t = t->ch[1];
            } else {
                p = t;
                t = t->ch[0];
            }
        }
        return p;
    }
    void dfs(Tp t, int dep = 0) {
        if (!t) {
            return;
        }
        push(t);
        dfs(t->ch[0], dep + 1);
        cout << t->info.val << ' ';
        // for (int i = 0; i < dep; i += 1) cerr << '\t';
        // cerr << t->info << ' ' << t->key << ' ' << t->rev << '\n';
        dfs(t->ch[1], dep + 1);
    }
};

struct Tag {
    constexpr operator bool() {
        return false;
    }
    void apply(const Tag &t) {}
};
struct Info {
    using T = int;
    int val, siz;
    void reve() {}
    void up(const Info &lhs, const Info &rhs) {
        siz = lhs.siz + 1 + rhs.siz;
    }
    void init(int val) {
        this->val = val;
        siz = 1;
    }
    void apply(const Tag &t) {}
    friend ostream &operator<<(ostream &cout, Info rhs) {
        return cout << "Info: " << rhs.val << ' ' << rhs.siz;
    }
};


using treap = FHQ_treap<Info, Tag>;
using Tp = treap::Tp;
treap T;
```

#### 可持久化文艺平衡树

```cpp
__gnu_cxx::sfmt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());

u32 stk[200];

template<typename Info, typename Tag>
struct PersistentBalanceTree {
    struct Node;
    using Tp = u32_p<Node>;
    
    using T = Info::T;
    struct Node {
        Tp ch[2];
        Info info;
        int key;
        bool rev;
        Tag tag;
    };
    
    Tp __new() {
        Tp t = Tp::__new();
        t->key = rng();
        return t;
    }

    Tp __new(Tp t) {
        if (!t) return t;
        Tp p = Tp::__new();
        p->ch[0] = t->ch[0];
        p->ch[1] = t->ch[1];
        p->info = t->info;
        p->key = t->key;
        p->rev = t->rev;
        p->tag = t->tag;
        return p;
    }

    void apply(Tp t, const Tag &tag) {
        if (t) {
            t->info.apply(tag);
            t->tag.apply(tag);
        }
    }

    void push(Tp t) {
        if (t->rev || t->tag) {
            t->ch[0] = __new(t->ch[0]);
            t->ch[1] = __new(t->ch[1]);
            if (t->rev) {
                swap(t->ch[0], t->ch[1]);
                t->ch[0]->rev ^= 1;
                t->ch[0]->info.reve();
                t->ch[1]->rev ^= 1;
                t->ch[1]->info.reve();
                t->rev = 0;
            }
            if (t->tag) {
                apply(t->ch[0], t->tag);
                apply(t->ch[1], t->tag);
                t->tag = Tag();
            }
        }
    }

    void pull(Tp t) {
        t->info.up(t->ch[0]->info, t->ch[1]->info);
    }

    void rangeReverse(Tp &t, int x, int y) {
        // debug(x, y);
        auto [tmp, r] = split_by_rank(t, y);
        auto [l, m] = split_by_rank(tmp, x);
        m->rev ^= 1;
        m->info.reve();
        t = merge(l, merge(m, r));
    }

    void rangeApply(Tp &t, int x, int y, const Tag &tag) {
        auto [tmp, r] = split_by_rank(t, y);
        auto [l, m] = split_by_rank(tmp, x);
        apply(m, tag);
        t = merge(l, merge(m, r));
    }

    Info rangeQuery(Tp &t, int x, int y) {
        // debug(x, y);
        auto [tmp, r] = split_by_rank(t, y);
        auto [l, m] = split_by_rank(tmp, x);
        Info ans = m->info;
        t = merge(l, merge(m, r));
        return ans;
    }
//  split and merge
    pair<Tp, Tp> split_by_val(Tp &t, T val) {
        if (!t) {
            return {0, 0};
        }
        t = __new(t);
        push(t);
        Tp ohs;
        if (t->info.val < val) {
            tie(t->ch[1], ohs) = split_by_val(t->ch[1], val);
            pull(t);
            return {t, ohs};
        } else {
            tie(ohs, t->ch[0]) = split_by_val(t->ch[0], val);
            pull(t);
            return {ohs, t};
        }
    }

    pair<Tp, Tp> split_by_rank(Tp t, int rank) {
        if (!t) {
            return {t, t};
        }
        push(t);
        t = __new(t);
        Tp ohs;
        if (rank <= t->ch[0]->info.siz) {
            tie(ohs, t->ch[0]) = split_by_rank(t->ch[0], rank);
            pull(t);
            return {ohs, t};
        } else {
            tie(t->ch[1], ohs) = split_by_rank(t->ch[1], rank - 1 - t->ch[0]->info.siz);
            pull(t);
            return {t, ohs};
        }
    }
    
    template<bool isNew = false>
    Tp merge(Tp u, Tp v) {
        if (!u | !v) return u.x | v.x;
        if (u->key < v->key) {
            push(u);
            if (isNew) {
                u = __new(u);
            }
            u->ch[1] = merge<isNew>(u->ch[1], v);
            pull(u);
            return u;
        } else {
            push(v);
            if (isNew) {
                v = __new(v);
            }
            v->ch[0] = merge<isNew>(u, v->ch[0]);
            pull(v);
            return v;
        }
    }
//  split and merge


//  set operator

    // void insert_by_rank(Tp &t, int rank, Tp v) {
    //     auto [l, r] = split_by_rank(t, rank);
    //     t = merge(l, merge(v, r));
    // }

    void insert_by_rank(Tp &t, int rank, Tp v) {
        if (!t) {
            t = v;
            return;
        }
        push(t);
        t = __new(t);
        if (v->key < t->key) {
            tie(v->ch[0], v->ch[1]) = split_by_rank(t, rank);
            t = v;
            pull(t);
            return;
        }
        // debug(rank, t->ch[0]->info.siz);
        if (rank <= t->ch[0]->info.siz) {
            insert_by_rank(t->ch[0], rank, v);
        } else {
            insert_by_rank(t->ch[1], rank - 1 - t->ch[0]->info.siz, v);
        }
        pull(t);
    }

    // void erase_by_rank(Tp &t, int rank) {
    //     auto [tmp, r] = split_by_rank(t, rank);
    //     auto [l, m] = split_by_rank(tmp, rank - 1);
    //     t = merge(l, r);
    // }

    void erase_by_rank(Tp &t, int rank) {
        if (!t) return;
        push(t);
        t = __new(t);
        if (rank <= t->ch[0]->info.siz) {
            erase_by_rank(t->ch[0], rank);
            pull(t);
        } else if (rank > t->ch[0]->info.siz + 1) {
            erase_by_rank(t->ch[1], rank - 1 - t->ch[0]->info.siz);
            pull(t);
        } else {
            t = merge<true>(t->ch[0], t->ch[1]);
        }
    }

    void insert_by_val(Tp &t, Tp v) {
        t = __new(t);
        if (!t) {
            t = v;
            return;
        }
        if (t->key < v->key) {
            // push(t);
            tie(v->ch[0], v->ch[1]) = split_by_val(t, v->info.val);
            t = v;
            pull(t);
            return;
        }
        // t->info.siz += 1;
        insert_by_val(t->ch[v->info.val > t->info.val || (t->info.val == v->info.val && int(rng()) >= 0)], v);
        pull(t);
    }

    void erase_by_val(Tp &t, T v) {
        if (!t) return;
        t = __new(t);
        if (t->info.val == v) {
            t = merge(t->ch[0], t->ch[1]);
            return;
        } else {
            // t->info.siz -= 1;
            erase_by_val(t->ch[v > t->info.val], v);
            pull(t);
        }
    }
// not back
    void __insert_by_val(Tp &t, Tp v) {
        int Top = -1;
        Tp *p = &t;
        while (*p && v->key <= (*p)->key) {
            *p = __new(*p);
            stk[++ Top] = *p;
            p = &((*p)->ch[v->info.val > (*p)->info.val || ((*p)->info.val == v->info.val && int(rng()) >= 0)]);
        }
        if (*p) {
            tie(v->ch[0], v->ch[1]) = split_by_val(*p, v->info.val);
            pull(v);
        }
        *p = v;
        if (Top != -1) t = stk[0];
        while (Top != -1) {
            pull(stk[Top --]);
        }
    }

    void __erase_by_val(Tp &t, T v) {
        int Top = -1;
        Tp *p = &t;
        while (*p && (*p)->info.val != v) {
            *p = __new(*p);
            stk[++ Top] = *p;
            p = &((*p)->ch[v > (*p)->info.val]);
        }
        if (*p) {
            *p = merge((*p)->ch[0], (*p)->ch[1]);
        }
        if (Top != -1) t = stk[0];
        while (Top != -1) {
            pull(stk[Top --]);
        }
    }
// not back
    int less_to_val(Tp t, T val) {
        int less_siz = 0;
        while (t) {
            if (t->info.val >= val) {
                t = t->ch[0];
            } else {
                less_siz += t->ch[0]->info.siz + 1;
                t = t->ch[1];
            }
        }
        return less_siz;
    }
    Tp rank(Tp t, int rank) {
        while (true) {
            if (t->ch[0]->info.siz >= rank) {
                t = t->ch[0];
            } else if (t->ch[0]->info.siz + 1 < rank) {
                rank -= t->ch[0]->info.siz + 1;
                t = t->ch[1];
            } else
                break;
        }
        return t;
    }
    Tp prev_to_val(Tp t, T val) {
        Tp p;
        while (t) {
            if (t->info.val < val) {
                p = t;
                t = t->ch[1];
            } else {
                t = t->ch[0];
            }
        }
        return p;
    }
    Tp next_to_val(Tp t, T val) {
        Tp p;
        while (t) {
            if (t->info.val <= val) {
                t = t->ch[1];
            } else {
                p = t;
                t = t->ch[0];
            }
        }
        return p;
    }
    void dfs(Tp t, int dep = 0) {
        if (!t) {
            return;
        }
        dfs(t->ch[0], dep + 1);
        for (int i = 0; i < dep; i += 1) cerr << '\t';
        cerr << t->info << ' ' << t->key << ' ' << t->rev << '\n';
        dfs(t->ch[1], dep + 1);
    }
};

struct Tag {
    constexpr operator bool() {
        return false;
    }
    void apply(const Tag &t) {}
};
struct Info {
    using T = int;
    int val, siz;
    i64 sum;
    void reve() {}
    void up(const Info &lhs, const Info &rhs) {
        siz = lhs.siz + 1 + rhs.siz;
        sum = lhs.sum + val + rhs.sum;
    }
    void init(int val) {
        this->val = val;
        this->sum = val;
        siz = 1;
    }
    void apply(const Tag &t) {}
    friend ostream &operator<<(ostream &cout, Info rhs) {
        return cout << "Info: " << rhs.val << ' ' << rhs.sum << ' ' << rhs.siz;
    }
};

using treap = PersistentBalanceTree<Info, Tag>;
using Tp = treap::Tp;

treap T;
```

#### jls splay

```cpp
struct Tree {
    int add = 0;
    int val = 0;
    int id = 0;
    u32_p<Tree> ch[2], p;
};

using Tp = u32_p<Tree>;

Tp __new() {
    return Tp::__new();
}

int pos(Tp t) {
    return t->p->ch[1] == t;
}

void add(Tp t, int v) {
    t->val += v;
    t->add += v;
}

void push(Tp t) {
    if (t->ch[0]) {
        add(t->ch[0], t->add);
    }
    if (t->ch[1]) {
        add(t->ch[1], t->add);
    }
    t->add = 0;
}

void rotate(Tp t) {
    Tp q = t->p;
    int x = !pos(t);
    q->ch[!x] = t->ch[x];
    if (t->ch[x]) t->ch[x]->p = q;
    t->p = q->p;
    if (q->p) q->p->ch[pos(q)] = t;
    t->ch[x] = q;
    q->p = t;
}

void splay(Tp t) {
    std::vector<Tp > s;
    for (Tp i = t; i->p; i = i->p) s.push_back(i->p);
    while (!s.empty()) {
        push(s.back());
        s.pop_back();
    }
    push(t);
    while (t->p) {
        if (t->p->p) {
            if (pos(t) == pos(t->p)) rotate(t->p);
            else rotate(t);
        }
        rotate(t);
    }
}

void insert(Tp &t, Tp x, Tp p = 0) {
    if (!t) {
        t = x;
        x->p = p;
        return;
    }
    
    push(t);
    if (x->val < t->val) {
        insert(t->ch[0], x, t);
    } else {
        insert(t->ch[1], x, t);
    }
}

void dfs(Tp t) {
    if (!t) {
        return;
    }
    push(t);
    dfs(t->ch[0]);
    std::cerr << t->val << " ";
    dfs(t->ch[1]);
}

std::pair<Tp , Tp > split(Tp t, int x) {
    if (!t) {
        return {t, t};
    }
    Tp v = 0;
    Tp j = t;
    for (Tp i = t; i; ) {
        push(i);
        j = i;
        if (i->val >= x) {
            v = i;
            i = i->ch[0];
        } else {
            i = i->ch[1];
        }
    }
    
    splay(j);
    if (!v) {
        return {j, 0};
    }
    
    splay(v);
    
    Tp u = v->ch[0];
    if (u) {
        v->ch[0] = u->p = 0;
    }
    return {u, v};
}

Tp merge(Tp l, Tp r) {
    if (!l) {
        return r;
    }
    if (!r) {
        return l;
    }
    Tp i = l;
    while (i->ch[1]) {
        i = i->ch[1];
    }
    splay(i);
    i->ch[1] = r;
    r->p = i;
    return i;
}
```

## 线段树套平衡树

```cpp
constexpr int max_size = 262144000;
uint8_t buf[max_size];
uint8_t *head = buf;

using u32 = uint32_t;

template <class T>
struct u32_p {
    u32 x;
    u32_p(u32 x = 0) : x(x) {}
    T *operator->() {
        return (T *)(buf + x);
    }
    operator bool() {
        return x;
    }
    operator u32() {
        return x;
    }
    bool operator==(u32_p rhs) const {
        return x == rhs.x;
    }
    static u32_p __new() {
        // assert(x < max_size);
        return (head += sizeof(T)) - buf;
    }
};

/**
 * FHQ_treap set卡常:
 * 1.递归改非递归       x
 * 2.insert split优化   o
 */

__gnu_cxx::sfmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

template<typename Info>
struct FHQ_treap {
    struct Node;
    using Tp = u32_p<Node>;
    struct Node {
        Tp ch[2];
        Info val;
        int siz, key;
    };

    Tp root;

    void pull(Tp t) {
        t->siz = t->ch[0]->siz + 1 + t->ch[1]->siz;
    }
    // by val
    pair<Tp, Tp> split(Tp t, Info val) {
        if (!t) {
            return {t, t};
        }
        Tp ohs;
        if (t->val < val) {
            tie(t->ch[1], ohs) = split(t->ch[1], val);
            pull(t);
            return {t, ohs};
        } else {
            tie(ohs, t->ch[0]) = split(t->ch[0], val);
            pull(t);
            return {ohs, t};
        }
    }

    Tp merge(Tp u, Tp v) {
        if (!u | !v) return u.x | v.x;
        if (u->key < v->key) {
            u->ch[1] = merge(u->ch[1], v);
            pull(u);
            return u;
        } else {
            v->ch[0] = merge(u, v->ch[0]);
            pull(v);
            return v;
        }
    }

// set operator
    void insert(Tp &t, Tp v) {
        if (!t) {
            t = v;
            // ps;
            return;
        }
        if (t->key < v->key) {
            tie(v->ch[0], v->ch[1]) = split(t, v->val);
            t = v;
            pull(t);
            return;
        }
        // t->siz += 1;
        insert(t->ch[v->val > t->val || 
            (t->val == v->val && int(rng()) >= 0)], v);
        pull(t);
    }

    void insert(Info v) {
        Tp t = Tp::__new();
        t->key = rng();
        t->val = v;
        t->siz = 1;
        insert(root, t);
    }

    void erase(Tp &t, Info v) {
        if (t->val == v) {
            t = merge(t->ch[0], t->ch[1]);
            return;
        } else {
            // t->siz -= 1;
            erase(t->ch[v > t->val], v);
            pull(t);
        }
    }

    void erase(Info v) {
        erase(root, v);
    }
    // by val
    int less(Info v) {
        Tp t = root;
        int less_siz = 0;
        while (t) {
            if (t->val >= v) {
                t = t->ch[0];
            } else {
                less_siz += t->ch[0]->siz + 1;
                t = t->ch[1];
            }
        }
        return less_siz;
    }
    // from zero
    Tp rank(Tp t, int k) {
        k += 1;
        while (true) {
            if (t->ch[0]->siz >= k) {
                t = t->ch[0];
            } else if (t->ch[0]->siz + 1 < k) {
                k -= t->ch[0]->siz + 1;
                t = t->ch[1];
            } else
                break;
        }
        return t;
    }
    // from zero
    Tp operator[] (int k) {
        return rank(root, k);
    }
    // by val
    static constexpr int inf = std::numeric_limits<int>::max();
    Info prev(Info v) {
        Tp t = root, p;
        while (t) {
            if (t->val < v) {
                p = t;
                t = t->ch[1];
            } else {
                t = t->ch[0];
            }
        }
        return p ? p->val : -inf;
    }
    // by val
    Info next(Info v) {
        Tp t = root, p;
        while (t) {
            if (t->val <= v) {
                t = t->ch[1];
            } else {
                p = t;
                t = t->ch[0];
            }
        }
        return p ? p->val : inf;
    }
    void dfs(Tp t, int dep = 0) {
        if (!t) {
            return;
        }
        dfs(t->ch[0], dep + 1);
        for (int i = 0; i < dep; i += 1) cerr << '\t';
        cerr << t->val << ' ' << t->key << '\n';
        dfs(t->ch[1], dep + 1);
    }
    void dfs() {return dfs(root);}
};

template<typename Value>
struct SegTreap {
    int n;
    vector<Value> val;
    vector<FHQ_treap<Value>> info;
    SegTreap() : n(0) {}
    SegTreap(int n_, Value v_ = Value()) {
        init(n_, v_);
    }
    template<class T>
    SegTreap(vector<T> init_) {
        init(init_);
    }
    void init(int n_, Value v_ = Value()) {
        init(vector(n_, v_));
    }
    template<class T>
    void init(vector<T> init_) {
        n = init_.size();
        val = init_;
        info.assign(4 << __lg(n), {});
        function<void(int, int, int)> 
        build = [&](int p, int l, int r) {
            for (int i = l; i < r; i += 1) {
                info[p].insert(val[i]);
            }
            if (r - l == 1) {
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
        };
        build(1, 0, n);
    }
    void modify(int p, int l, int r, int x, const Value &v) {
        info[p].erase(val[x]);
        info[p].insert(v);
        if (r - l == 1) return;
        int m = (l + r) / 2;
        if (x < m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
    }
    void modify(int p, const Value &v) {
        if(p >= n) return;
        modify(1, 0, n, p, v);
        val[p] = v;
    }
    int less(int p, int l, int r, int x, int y, const Value &v) {
        if (l >= x && r <= y) {
            return info[p].less(v);
        }
        int m = (l + r) / 2;
        if (m >= y) {
            return less(2 * p, l, m, x, y, v);
        } else if (m <= x) {
            return less(2 * p + 1, m, r, x, y, v);
        } else {
            return less(2 * p, l, m, x, y, v) + less(2 * p + 1, m, r, x, y, v);
        }
    }
    int less(int l, int r, const Value &v) {
        if (l >= r) return 0;
        return less(1, 0, n, l, r, v);
    }

    // from zero
    Value kth (int x, int y, int k) {
        int l = 0, r = 1e8 + 1;
        while (l + 1 != r) {
            int m = l + r >> 1;
            if (less(x, y, m) <= k) l = m;
            else r = m;
        }
        return l;
    }

    Value prev(int p, int l, int r, int x, int y, const Value &v) {
        if (l >= x && r <= y) {
            return info[p].prev(v);
        }
        int m = (l + r) / 2;
        if (m >= y) {
            return prev(2 * p, l, m, x, y, v);
        } else if (m <= x) {
            return prev(2 * p + 1, m, r, x, y, v);
        } else {
            return std::max(prev(2 * p, l, m, x, y, v), prev(2 * p + 1, m, r, x, y, v));
        }
    }

    Value prev(int x, int y, const Value &v) {
        return prev(1, 0, n, x, y, v);
    }

    Value next(int p, int l, int r, int x, int y, const Value &v) {
        if (l >= x && r <= y) {
            return info[p].next(v);
        }
        int m = (l + r) / 2;
        if (m >= y) {
            return next(2 * p, l, m, x, y, v);
        } else if (m <= x) {
            return next(2 * p + 1, m, r, x, y, v);
        } else {
            return std::min(next(2 * p, l, m, x, y, v), next(2 * p + 1, m, r, x, y, v));
        }
    }

    Value next(int x, int y, const Value &v) {
        return next(1, 0, n, x, y, v);
    }

    void show(int p, int l, int r, int x, int y, int dep = 0) {
        if (l >= y || r <= x) return;
        int m = (l + r) >> 1;
        if (r - l > 1)
        show(p * 2, l, m, x, y, dep + 1);
        for (int i = 0; i < dep; i += 1) {
            cerr << '\t';
        }
        cerr << l << ' ' << r << ' '; info[p].show();
        cerr << '\n';
        if (r - l > 1)
        show(p * 2 + 1, m, r, x, y, dep + 1);
    }
    void show(int l, int r) {
        show(1, 0, n, l, r);
    }
};

using Tree = SegTreap<int>;
```

## 树状数组

### 标准版

```cpp
template<typename T>
struct Fenwick {
    int n;
    std::vector <T> a;

    Fenwick(int n_ = 0) {
        init(n_);
    }

    void init(int n_) {
        n = n_;
        a.assign(n, T{});
    }

    void add(int x, const T &v) {
        if (x < 0 || x >= n) return;
        for (int i = x + 1; i <= n; i += i & -i) {
            a[i - 1] = a[i - 1] + v;
        }
    }

    T Query(int x) {
        if (x <= 0) return T{};
        if (x > n) x = n;
        T ans{};
        for (int i = x; i != 0; i -= i & -i) {
            ans = ans + a[i - 1];
        }
        return ans;
    }

    T range_Query(int l, int r) {
        if (l >= r) return 0;
        return Query(r) - Query(l);
    }

    int kth(const T &k) {
        int x = 0;
        T cur{};
        for (int i = 1 << std::__lg(n); i; i /= 2) {
            if (x + i <= n && cur + a[x + i - 1] < k) {
                x += i;
                cur = cur + a[x - 1];
            }
        }
        return x;
    }
};
```

### 二维树状数组

```cpp
template<typename T>
struct Two_dimensional_Fenwick {
    struct Base_Fenwick {
        int n, m;
        std::vector <std::vector<T>> s;

        Base_Fenwick(int _n = 0, int _m = 0) {
            init(_n, _m);
        }

        void init(int _n, int _m) {
            n = _n, m = _m;
            s.assign(n + 1, std::vector<T>(m + 1, T()));
        }

        void change(int x, int y, const T &v) {
            if (x <= 0 || y <= 0) return;
            if (x > n) x = n;
            if (y > m) y = m;
            for (int i = x; i <= n; i += i & (-i))
                for (int j = y; j <= m; j += j & (-j))
                    s[i][j] += v;
        }

        T Query(int x, int y) {
            if (x <= 0 || y <= 0) return T();
            if (x > n) x = n;
            if (y > m) y = m;
            T ans = 0;
            for (int i = x; i != 0; i -= i & (-i))
                for (int j = y; j != 0; j -= j & (-j))
                    ans += s[i][j];
            return ans;
        }
    };

    int n, m;
    Base_Fenwick A, B, C, D;

    Two_dimensional_Fenwick(int _n = 0, int _m = 0) {
        init(_n, _m);
    }

    void init(int _n, int _m) {
        n = _n, m = _m;
        A.init(n, m);
        B.init(n, m);
        C.init(n, m);
        D.init(n, m);
    }

    void Base_add(int x, int y, int v) {
        A.change(x, y, v);
        B.change(x, y, v * x);
        C.change(x, y, v * y);
        D.change(x, y, v * x * y);
    }

    T Base_Query(int x, int y) {
        return A.Query(x, y) * (x * y + x + y + 1)
               - B.Query(x, y) * (y + 1)
               - C.Query(x, y) * (x + 1)
               + D.Query(x, y);
    }

    void add(int x0, int y0, int x1, int y1, int v) {
        Base_add(x0, y0, v);
        Base_add(x0, y1 + 1, -v);
        Base_add(x1 + 1, y0, -v);
        Base_add(x1 + 1, y1 + 1, v);
    }

    T Query(int x0, int y0, int x1, int y1) {
        return Base_Query(x1, y1) - Base_Query(x0 - 1, y1)
               - Base_Query(x1, y0 - 1) + Base_Query(x0 - 1, y0 - 1);
    }
};
```

### 区间加树状数组

```cpp
template<typename T> 
struct Range_Fenwick {
    int n;
    Fenwick <T> a, b;

    Range_Fenwick (int _n = 0) {
        init (_n);
    }

    void init (int _n) {
        n = _n;
        a.init(n); b.init(n);
    }

    void range_Change (int l, int r, const T& k) {
        a.add(l, k); a.add(r + 1, -k);
        b.add(l, k * l); b.add(r + 1, -k * (r + 1)) ;
    }

    T range_Query (int l, int r) {
        return (r + 1) * a.Query(r) - l * a.Query(l - 1) - b.range_Query(l, r);
    }

    int kth(const T &k) {
        int x = 0;
        T cur0{}, cur1{};
        for (int i = 1 << std::__lg(n); i; i /= 2) {
            if (x + i <= n && (cur0 + a.a[x + i]) * (x + i + 1) - (cur1 + b.a[x + i]) < k) {
                x += i;
                cur0 = cur0 + a.a[x];
                cur1 = cur1 + b.a[x];
            }
        }
        return x + 1;
    }
};
```

## 线段树

### 单点

```cpp
template<class Info>
struct SegmentTree {
    int n;
    std::vector<Info> info;
    SegmentTree() : n(0) {}
    SegmentTree(int n_, Info v_ = Info()) {
        init(n_, v_);
    }
    template<class T>
    SegmentTree(std::vector<T> init_) {
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {
        init(std::vector(n_, v_));
    }
    template<class T>
    void init(std::vector<T> init_) {
        n = init_.size();
        info.assign(4 << std::__lg(n), Info());
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p, l, m, r);
        };
        build(1, 0, n);
    }
    void pull(int p, int l, int m, int r) {
        info[p].update(info[2 * p], info[2 * p + 1], l, m, r);
    }
    void modify(int p, int l, int r, int x, const Info &v) {
        if (r - l == 1) {
            info[p].apply(v, l, r);
            return;
        }
        int m = (l + r) / 2;
        if (x < m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p, l, m, r);
    }
    void modify(int p, const Info &v) {
        if(p >= n) return;
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {
        if (l >= x && r <= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        if (m >= y) {
            return rangeQuery(2 * p, l, m, x, y);
        } else if (m <= x) {
            return rangeQuery(2 * p + 1, m, r, x, y);
        } else {
            return Info::merge(rangeQuery(2 * p, l, m, x, y), rangeQuery(2 * p + 1, m, r, x, y), std::max(l, x), m, std::min(r, y));
        }
    }
    Info rangeQuery(int l, int r) {
        if (l >= r) return Info();
        return rangeQuery(1, 0, n, l, r);
    }
    // int BS(int p, int l, int r, i64 k) {
    //     // debug(l, r, k, info[p]);
    //     if (info[p] < k) return -1;
    //     if (r - l == 1) return l;
    //     int m = (l + r) / 2;
    //     if (info[p * 2].sum >= k) 
    //         return BS(p * 2, l, m, k);
    //     else 
    //         return BS(p * 2 + 1, m, r, k - info[p * 2].sum);
    // };
    // int BS(i64 k) {
    //     // debug(k);
    //     return BS(1, 0, n, k);
    // }

    template<class F>
    int findFirst(int p, int l, int r, int x, int y, F pred) {
        if (l >= y || r <= x || !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        int res = findFirst(2 * p, l, m, x, y, pred);
        if (res == -1) {
            res = findFirst(2 * p + 1, m, r, x, y, pred);
        }
        return res;
    }
    template<class F>
    int findFirst(int l, int r, F pred) {
        return findFirst(1, 0, n, l, r, pred);
    }
    template<class F>
    int findLast(int p, int l, int r, int x, int y, F pred) {
        if (l >= y || r <= x || !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        int res = findLast(2 * p + 1, m, r, x, y, pred);
        if (res == -1) {
            res = findLast(2 * p, l, m, x, y, pred);
        }
        return res;
    }
    template<class F>
    int findLast(int l, int r, F pred) {
        return findLast(1, 0, n, l, r, pred);
    }
    void show(int p, int l, int r, int x, int y, int dep = 0) {
        if (l >= y || r <= x) return;
        int m = (l + r) >> 1;
        if (r - l > 1)
        show(p * 2, l, m, x, y, dep + 1);
        for (int i = 0; i < dep; i += 1) {
            cerr << '\t';
        }
        cerr << l << ' ' << r << ' '; info[p].show();
        cerr << '\n';
        if (r - l > 1)
        show(p * 2 + 1, m, r, x, y, dep + 1);
    }
    void show(int l, int r) {
        show(1, 0, n, l, r);
    }
};

struct Info {
    void apply(const Info &rhs, int l, int r) {}
    void update(const Info &lhs, const Info &rhs, int l, int m, int r) {}
    static Info merge(const Info &lhs, const Info &rhs, int l, int m, int r) {
        Info info = Info();
        info.update(lhs, rhs, l, m, r);
        return info;
    }
    void show() const {
        cerr << "info: ";
    }
};

using Tree = SegmentTree<Info>;
```

### 区间

```cpp
template<class Info, class Tag>
struct LazySegmentTree {
    int n;
    std::vector<Info> info;
    std::vector<Tag> tag;
    LazySegmentTree() : n(0) {}
    LazySegmentTree(int n_, Info v_ = Info()) {
        init(n_, v_);
    }
    template<class T>
    LazySegmentTree(std::vector<T> init_) {
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {
        init(std::vector(n_, v_));
    }
    template<class T>
    void init(std::vector<T> init_) {
        n = init_.size();
        info.assign(n * 4, Info());
        tag.assign(n * 4, Tag());
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
            pull(p, l, m, r);
        };
        build(1, 0, n);
    }
    void pull(int p, int l, int m, int r) {
        info[p].update(info[2 * p], info[2 * p + 1], l, m, r);
    }
    void apply(int p, const Tag &v, int l, int r) {
        info[p].apply(v, l, r);
        tag[p].apply(v);
    }
    void push(int p, int l, int m, int r) {
        if (bool(tag[p])) {
            apply(2 * p, tag[p], l, m);
            apply(2 * p + 1, tag[p], m, r);
            tag[p] = Tag();
        }
    }
    void modify(int p, int l, int r, int x, const Info &v) {
        if (r - l == 1) {
            info[p] = v;
            return;
        }
        int m = (l + r) / 2;
        push(p, l, m, r);
        if (x < m) {
            modify(2 * p, l, m, x, v);
        } else {
            modify(2 * p + 1, m, r, x, v);
        }
        pull(p, l, m, r);
    }
    void modify(int p, const Info &v) {
        modify(1, 0, n, p, v);
    }
    Info rangeQuery(int p, int l, int r, int x, int y) {
        if (l >= x && r <= y) {
            return info[p];
        }
        int m = (l + r) / 2;
        push(p, l, m, r);
        if (m >= y) {
            return rangeQuery(2 * p, l, m, x, y);
        } else if (m <= x) {
            return rangeQuery(2 * p + 1, m, r, x, y);
        } else {
            return Info::merge(rangeQuery(2 * p, l, m, x, y), rangeQuery(2 * p + 1, m, r, x, y), l, m, r);
        }
    }
    Info rangeQuery(int l, int r) {
        if (l >= r) return Info();
        return rangeQuery(1, 0, n, l, r);
    }
    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {
        if (l >= y || r <= x) {
            return;
        }
        int m = (l + r) / 2;
        if (l >= x && r <= y) {
            apply(p, v, l, r);
            return;
        }
        push(p, l, m, r);
        rangeApply(2 * p, l, m, x, y, v);
        rangeApply(2 * p + 1, m, r, x, y, v);
        pull(p, l, m, r);
    }
    void rangeApply(int l, int r, const Tag &v) {
        return rangeApply(1, 0, n, l, r, v);
    }
    template<class F>
    int findFirst(int p, int l, int r, int x, int y, F pred) {
        if (l >= y || r <= x || !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        push(p, l, m, r);
        int res = findFirst(2 * p, l, m, x, y, pred);
        if (res == -1) {
            res = findFirst(2 * p + 1, m, r, x, y, pred);
        }
        return res;
    }
    template<class F>
    int findFirst(int l, int r, F pred) {
        return findFirst(1, 0, n, l, r, pred);
    }
    template<class F>
    int findLast(int p, int l, int r, int x, int y, F pred) {
        if (l >= y || r <= x || !pred(info[p])) {
            return -1;
        }
        if (r - l == 1) {
            return l;
        }
        int m = (l + r) / 2;
        push(p, l, m, r);
        int res = findLast(2 * p + 1, m, r, x, y, pred);
        if (res == -1) {
            res = findLast(2 * p, l, m, x, y, pred);
        }
        return res;
    }
    template<class F>
    int findLast(int l, int r, F pred) {
        return findLast(1, 0, n, l, r, pred);
    }
    void show(int p, int l, int r, int x, int y, int dep = 0) {
        if (l >= y || r <= x) return;
        int m = (l + r) >> 1;
        if (r - l > 1)
        show(p * 2, l, m, x, y, dep + 1);
        for (int i = 0; i < dep; i += 1) {
            cerr << '\t';
        }
        cerr << l << ' ' << r << ' '; info[p].show(), tag[p].show();
        cerr << '\n';
        if (r - l > 1)
        show(p * 2 + 1, m, r, x, y, dep + 1);
    }
    void show(int l, int r) {
        show(1, 0, n, l, r);
    }
};

constexpr i64 inf = 1e18;

struct Tag {
    i64 d = 0;
    void apply(Tag t) {
        d += t.d;
    }
    operator bool() {
        return d != 0;
    }
    void show() const {
# ifdef LOCAL
        cerr << "tag: " << d << ";";
# endif
    }
};

constexpr int N = 20;

struct Info {
    array<double, 2> val{0, 1};
    void apply(const Tag &t, int l, int r) {
        tie(val[0], val[1]) 
            = make_tuple(val[0] * cos(t.d) + val[1] * sin(t.d),
                         val[1] * cos(t.d) - val[0] * sin(t.d));
    }
    void update(const Info &lhs, const Info &rhs, int l, int m, int r) {
        for (auto i : {0, 1}) {
            val[i] = lhs.val[i] + rhs.val[i];
        }
    }   
    static Info merge(const Info &lhs, const Info &rhs, int l, int m, int r) {
        Info info = Info();
        info.update(lhs, rhs, l, m, r);
        return info;
    }
    void show() {
# ifdef LOCAL
        cerr << "info: " << val << "; ";
# endif
    }
};

using lazySegmentTree = LazySegmentTree<Info, Tag>;
```

### tourist zkw 线段树（精简版）区间最大值

```cpp
struct SegmTree {
  vector<int> T; int n;
  SegmTree(int n) : T(2 * n, (int)-2e9), n(n) {}
  
  void Update(int pos, int val) {
    for (T[pos += n] = val; pos > 1; pos /= 2)
      T[pos / 2] = max(T[pos], T[pos ^ 1]);
  }
  
  int Query(int b, int e) {
    int res = -2e9;
    for (b += n, e += n; b < e; b /= 2, e /= 2) {
      if (b % 2) res = max(res, T[b++]);
      if (e % 2) res = max(res, T[--e]);
    }
    return res;
  }
};
```

### 动态开点线段树

```cpp
/**
 * 262144000
**/
constexpr int max_size = 262144000;
uint8_t buf[max_size];
uint8_t *head = buf;

using Tp = long long;
template<typename Info, typename Tag>
struct segment_tree {
    int n;
    struct node {
        Info info;
        Tag tag;
        array<int, 2> _ch;
        node(): info(), tag(), _ch{} {}
        node *ch(int x) const {
            return (node *)(_ch[x] + buf);
        }
        void clear() {
            *this = node();
        }
    };
    using p_Tp = node *;
    int root{0};
    int _new(Tp l, Tp r) {
        int cur = (head += sizeof(node)) - buf;
        p_Tp p = p_Tp(buf + cur);
        // p->info = Info::merge(l, r);
        assert(cur < max_size);
        return cur;
    }
    void apply(int &cur, const Tag &v, Tp l, Tp r) {
        if (!cur) {
            cur = _new(l, r);
        }
        p_Tp p = p_Tp(buf + cur);
        p->info.apply(v, l, r);
        p->tag.apply(v);
    }
    void push(int &cur, Tp l, Tp m, Tp r) {
        p_Tp p = p_Tp(buf + cur);
        // assert(l < r);
        if (!bool(p->tag))
            return;
        apply(p->_ch[0], p->tag, l, m);
        apply(p->_ch[1], p->tag, m, r);
        p->tag.clear();
    }
    void pull(int &cur, Tp l, Tp m, Tp r) {
        p_Tp p = p_Tp(buf + cur);
        p->info.update(p->ch(0)->info, p->ch(1)->info, l, m, r);
    }
    Tp floor, ceil;
    segment_tree(Tp floor, Tp ceil) : floor(floor) , ceil(ceil) {}
    void modify(int &cur, const Tag &v, Tp l, Tp r, Tp x) {
        if (!cur)
            cur = _new(l, r);
        p_Tp p = p_Tp(buf + cur);
        Tp m = (l + r) >> 1;
        if (r - l == 1) {
            p->info.apply(v, l, r);
            return;
        }
        // push(cur, l, m, r);
        if (m > x)
            modify(p->_ch[0], v, l, m, x);
        else
            modify(p->_ch[1], v, m, r, x);
        pull(cur, l, m, r);
    }
    void modify(Tp x, const Tag &v) {
        modify(root, v, floor, ceil, x);
    }
    void rangeApply(int &cur, const Tag &v, Tp l, Tp r, Tp x, Tp y) {
        if (!cur)
            cur = _new(l, r);
        p_Tp p = p_Tp(buf + cur);
        Tp m = (l + r) >> 1;
        if (x <= l && r <= y) {
            apply(cur, v, l, r);
            return;
        }
        push(cur, l, m, r);
        if (m > x)
            rangeApply(p->_ch[0], v, l, m, x, y);
        if (m < y)
            rangeApply(p->_ch[1], v, m, r, x, y);
        pull(cur, l, m, r);
    }
    void rangeApply(Tp x, Tp y, const Tag &v) {
        if (x >= y) return;
        rangeApply(root, v, floor, ceil, x, y);
    }
    Info Query(int &cur, Tp l, Tp r, Tp x) {
        if (!cur)
            return Info::merge(l, r);
        p_Tp p = p_Tp(buf + cur);
        Tp m = (l + r) >> 1;
        if (r - l == 1) {
            return p->info;
        }
        // push(cur, l, m, r);
        if (m > x)
            return Query(p->_ch[0], l, m, x);
        else
            return Query(p->_ch[1], m, r, x);
    }
    Info Query(Tp x) {
        return Query(root, floor, ceil, x);
    }
    Info rangeQuery(int &cur, Tp l, Tp r, Tp x, Tp y) {
        if (!cur)
            return Info::merge(l, r);
        p_Tp p = p_Tp(buf + cur);
        Tp m = (l + r) >> 1;
        if (x <= l && r <= y) {
            return p->info;
        }
        push(cur, l, m, r);
        if (m >= y) {
            return rangeQuery(p->_ch[0], l, m, x, y);
        } else if (m <= x) {
            return rangeQuery(p->_ch[1], m, r, x, y);
        } else {
            return Info::merge(rangeQuery(p->_ch[0], l, m, x, y), rangeQuery(p->_ch[1], m, r, x, y), l, m, r);
        }
    }
    Info rangeQuery(Tp x, Tp y) {
        return rangeQuery(root, floor, ceil, x, y);
    }
    double BS(int &cur, Tp l, Tp r, i64 k) {
        if (!cur) cur = _new(l, r);

        p_Tp p = p_Tp(buf + cur);

        // debug(l, r, k, p->info);

        if (r - l == 1) {
            assert(p->info != 0);
            // if (p->info == 0) exit(0);
            return l + 1. * k / p->info;
        }

        Tp m = (l + r) >> 1;
        push(cur, l, m, r);

        if (p->ch(0)->info >= k)
            return BS(p->_ch[0], l, m, k);
        else 
            return BS(p->_ch[1], m, r, k - p->ch(0)->info);
    }
    double BS(i64 k) {
        return BS(root, floor, ceil, k);
    }
    void show(int &cur, Tp l, Tp r, Tp x, Tp y, int dep = 0) {
        if (l >= y || r <= x || !cur) return;
        p_Tp p = p_Tp(buf + cur);
        Tp m = (l + r) >> 1;
        if (r - l > 1)
        show(p->_ch[0], l, m, x, y, dep + 1);
        for (int i = 0; i < dep; i += 1) cerr << '\t';
        cerr << l << ' ' << r << ' '; p->info.show(), p->tag.show();
        cerr << '\n';
        if (r - l > 1)
        show(p->_ch[1], m, r, x, y, dep + 1);
    }
    void show(Tp x, Tp y) {
        show(root, floor, ceil, x, y);
    }
    p_Tp p_Tp_root() { return p_Tp(buf + root); }
};

struct Tag {
    int x = 0;
    void apply(const Tag &rhs) {
        x += rhs.x;
    }
    operator bool() {
        return x != 0;
    }
    void clear() {
        x = 0;
    }
    void show() const {
# ifdef LOCAL
        cerr << "Tag: " << x;
# endif
    }
};

struct Info {
    i64 x = 0;
    operator i64() {
        return x;
    }

    void apply(const Tag &rhs, Tp l, Tp r) {
        x += rhs.x * (r - l);
    }
    void update(const Info &lhs, const Info &rhs, Tp l, Tp m, Tp r) {
        x = lhs.x + rhs.x;
    }
    static Info merge(const Info &lhs, const Info &rhs, Tp l, Tp m, Tp r) {
        Info info = Info();
        info.update(lhs, rhs, l, m, r);
        return info;
    }
    static Info merge(Tp l, Tp r) {
        return {0};
    }
    void show() const {
# ifdef LOCAL
        cerr << "Info: " << x << ' ';
# endif
    }
};

using SegmentTree = segment_tree<Info, Tag>;
```

### 线段树分治

```cpp
template<class Info>
struct SegmentTree {
    int n;
    std::vector<Info> info;
    SegmentTree() : n(0) {}
    SegmentTree(int n_, Info v_ = Info()) {
        init(n_, v_);
    }
    template<class T>
    SegmentTree(std::vector<T> init_) {
        init(init_);
    }
    void init(int n_, Info v_ = Info()) {
        init(std::vector(n_, v_));
    }
    template<class T>
    void init(std::vector<T> init_) {
        n = init_.size();
        info.assign(4 << std::__lg(n), Info());
        std::function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (r - l == 1) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m, r);
        };
        build(1, 0, n);
    }
    void rangeChange(int x, int y, const Info &tag) {
        std::function<void(int, int, int, int, int, const Info&)> 
            rangeChange = [&] (int p, int l, int r, int x, int y, const Info &tag) {
            if (l >= y || r <= x) {
                return;
            }
            if (l >= x && r <= y) {
                info[p].apply(tag);
                return;
            }
            int m = (l + r) / 2;
            rangeChange(p << 1, l, m, x, y, tag);
            rangeChange(p << 1 | 1, m, r, x, y, tag);
        };
        rangeChange(1, 0, n, x, y, tag);
    }
};

struct Info {
    vector<array<ll, 2>> x;
    void apply(const Info& tag) {
        for (auto u : tag.x) {
            x.push_back(u);
        }
    }
};

using Segmenttree = SegmentTree<Info>;
```

### 可持久化线段树

```cpp
constexpr int max_size = 262144000;
uint8_t _buf[max_size];
uint8_t *head = _buf;

template<typename Info>
struct persistent_segment_tree {
    int n;
    struct node {
        Info m_info;
        int ls, rs;
        node () : m_info(), ls(), rs() {}
        void reset () {
            *this = node();
        }
    };
    using pointer = node *;
    int _new() {
        assert(head < _buf + max_size);
        return (head += sizeof(node)) - _buf;
    }
    vector<int> root;
    persistent_segment_tree(): n(0) {} 
    persistent_segment_tree(int _n, Info _v = Info()) {
        _init(std::vector(_n, _v));
    } 
    template<typename T>
    persistent_segment_tree(std::vector<T> _init) {
        _init(_init);
    }
    void _pull(int cur1) {
        pointer p1 = pointer(_buf + cur1);
        pointer lc = pointer(_buf + p1->ls);
        pointer rc = pointer(_buf + p1->rs);
        p1->m_info.set(Info::op(lc->m_info, rc->m_info));
    }
    template<typename T>
    void _init(std::vector<T> _init) {
        n = _init.size();
        root.push_back(_new());
        std::function<void(int, int, int)>
        build = [&] (int cur, int l, int r) {
            pointer p = pointer(_buf + cur);
            if (r - l == 1) {
                p->m_info = _init[l];
                return;
            }
            int m = (l + r) / 2;
            p->ls = _new(), p->rs = _new();
            build(p->ls, l, m), build(p->rs, m, r);
            _pull(cur);
        };
        build(root.back(), 0, n);
    }
    template<typename Tag>
    void _modify(int cur0, int cur1, const Tag &v, int l, int r, int x) {
        pointer p0 = pointer(_buf + cur0), p1 = pointer(_buf + cur1);
        if (r - l == 1) {
            p1->m_info = p0->m_info;
            p1->m_info.apply(v);
            return;
        }
        int m = (l + r) >> 1;
        if (m > x) {
            p1->ls = _new();
            p1->rs = p0->rs;
            _modify(p0->ls, p1->ls, v, l, m, x);
        } else {
            p1->ls = p0->ls;
            p1->rs = _new();
            _modify(p0->rs, p1->rs, v, m, r, x);
        }
        _pull(cur1);
    }
    template<typename Tag>
    void modify(int x, const Tag &v, int from = -1) {
        int cur0 = (from == -1 ? root.back() : root[from]);
        int cur1 = _new();
        root.push_back(cur1);
        _modify(cur0, cur1, v, 0, n, x);
    }
    typename Info::op_t _range_query(int cur0, int cur1, int l, int r, int x, int y) {
        pointer p0 = pointer(_buf + cur0), p1 = pointer(_buf + cur1);
        if (x <= l && r <= y) {
            return Info::del(p1->m_info, p0->m_info);
        }
        int m = (l + r) >> 1;
        if (m >= y) {
            return _range_query(p0->ls, p1->ls, l, m, x, y);
        } else if (m <= x) {
            return _range_query(p0->rs, p1->rs, m, r, x, y);
        } else {
            return Info::op(_range_query(p0->ls, p1->ls, l, m, x, y), _range_query(p0->rs, p1->rs, m, r, x, y));
        }
    }
    typename Info::op_t range_query(int from, int to, int x, int y) {
        return _range_query(root[from], root[to], 0, n, x, y);
    }
    typename Info::op1_t _kth(int cur0, int cur1, int l, int r, i64 k) {
        pointer p0 = pointer(_buf + cur0), p1 = pointer(_buf + cur1);
        pointer ls0 = pointer(_buf + p0->ls), ls1 = pointer(_buf + p1->ls);
        if (r - l == 1) {
            return Info::op1(l, Info::op1(k));
        }
        int m = (l + r) >> 1;
        typename Info::op1_t lhs = Info::del1(ls1->m_info, ls0->m_info);
        if (int(lhs) >= k) {
            return _kth(p0->ls, p1->ls, l, m, k);
        } else {
            return Info::op1(lhs, _kth(p0->rs, p1->rs, m, r, k - int(lhs)));
        }
    }
    typename Info::op1_t kth(int from, int to, i64 k) {
        return _kth(root[from], root[to], 0, n, k);
    }
    void _show(int cur, int l, int r) {
        pointer p = pointer(_buf + cur);
        if (r - l == 1) {
            p->m_info.show();
            return;
        }
        int m = (l + r) >> 1;
        _show(p->ls, l, m);
        _show(p->rs, m, r);
    }
    void show(int time) {
        _show(root[time],0, n);
    }
};

struct Info {
    i64 cnt = 0;
    using op_t = int;
    using op1_t = int;
    operator op_t() {
        return cnt;
    }
    void set(op_t rhs) {
        cnt = rhs;
    }
    static op_t op(op_t lhs, op_t rhs) {
        return lhs + rhs;
    }
    static op_t del(op_t lhs, op_t rhs) {
        return lhs - rhs;
    }
    static array<ll, 1> op1 (i64 k) {
        return array<ll, 1>{0};
    }
    static op1_t op1(int x, array<ll, 1> mul) {
        return x;
    }
    static op1_t op1(op1_t lhs, op1_t rhs) {
        return rhs;
    }
    static op1_t del1(op1_t lhs, op1_t rhs) {
        return lhs - rhs;
    }
    void apply(Info x) {
        cnt += x.cnt;
    }
    void show() {
        cerr << cnt << ' ';
    }
};

using SegmentTree = persistent_segment_tree<Info>;
```

### 李超线段树

```cpp
template<typename T, class Line, class Cmp>
struct Li_Chao_SegmentTree {
    int n;
    std::vector<int> id;
    std::vector<T> real;
    std::vector<Line> line;
    Cmp cmp;
    Li_Chao_SegmentTree() {}
    Li_Chao_SegmentTree(int _n) {
        init(_n);
    }
    Li_Chao_SegmentTree(const std::vector<T> &_init) {
        init(_init);
    }
    void init(int _n) {
        std::vector<int> _init(_n);
        iota(_init.begin(), _init.end(), 0);
        init(_init);
    }
    void init(const std::vector<T> &_init) {
        n = _init.size();
        id.assign(4 << std::__lg(n), 0);
        line.push_back(Line());
        real = _init;
        sort(real.begin(), real.end());
        real.erase(std::unique(real.begin(), real.end()), real.end());
        real.push_back(real.back() + 1);
    }
    void rangeChange (int x, int y, Line add) {
        int u = line.size();
        line.push_back(add);
        std::function<void(int, int, int, int)>
        range_Change = [&] (int l, int r, int p, int u) {
            int &v = id[p], m = (l + r) / 2;
            if (cmp(line, u, v, real[m])) {
                swap(u, v);
            }
            if (cmp(line, u, v, real[l])) {
                range_Change(l, m, p * 2, u);
            }
            if (cmp(line, u, v, real[r - 1])) {
                range_Change(m, r, p * 2 + 1, u);
            }
        };
        std::function<void(int, int, int)>
        range_find = [&] (int l, int r, int p) {
            if (real[l] >= y || real[r] <= x) {
                return;
            }
            if (x <= real[l] && real[r] <= y) {
                range_Change(l, r, p, u);
                return;
            }
            int m = (l + r) / 2;
            range_find(l, m, p * 2);
            range_find(m, r, p * 2 + 1);
        };
        range_find(0, n, 1);
    }
    void insert(Line add) {
        rangeChange(real[0], real.back(), add);
    }
    int Query(int x) {
        std::function<int(int, int, int)>
        Query = [&] (int l, int r, int p) {
            if (r - l == 1) {
                return id[p];
            }
            int m = (l + r) / 2;
            int u = id[p], v = -1;
            if (x < real[m]) {
                v = Query(l, m, p * 2);
            } else {
                v = Query(m, r, p * 2 + 1);
            }
            return cmp(line, u, v, x) ? u : v;
        };
        return Query(0, n, 1);                              
    }
    T slope_dp_Query(int x) {
        return line[Query(x)](x);
    }
};

template<typename T>
struct Line {
    T k, b;
    Line(T k = 0, T b = 0) : k(k), b(b){}
    T operator()(T x) {
        return __int128(k) * x + b;
    }
};
template<>
struct Line<double> {
    double k, b;
    Line(double k = 0, double b = 0) : k(k), b(b){}
    template<typename T>
    Line(T x0, T y0, T x1, T y1) {
        if (x0 == x1) {
            k = 0;
            b = std::max(y0, y1);
        } else {
            k = (y0 - y1) / (0. + x0 - x1);
            b = y0 - k * x0;
        }
    }
    double operator()(double x) {
        return k * x + b;
    }
};

template<typename T>
struct Cmp {
    bool operator() (vector<Line<T>> &line, int u, int v, T x) {
        return line[u](x) < line[v](x) || (line[u](x) == line[v](x) && u < v);
    }
};
template<>
struct Cmp<double> {
    bool operator() (vector<Line<double>> &line, int u, int v, double x) {
        constexpr double exp = 1e-9;
        return line[u](x) - line[v](x) > exp || (std::abs(line[u](x) - line[v](x)) <= exp && u < v);
    }
};

template<typename T, typename T1 = int>
using SegmentTree = 
    Li_Chao_SegmentTree<T1, Line<T>, Cmp<T>>;
```

### 扫描线

```cpp
struct ScanLine {
    int n;
    struct Line {
        int x1, x2, y;
        int type;
        bool operator<(Line another) const {
            return y < another.y;
        }
    };

    struct Info {
        int l, r;
        int len = 0, cnt = 0;
    };
    vector<Info> info;
    vector<Line> line;
    vector<int> X;

    void add(int x1, int y1, int x2, int y2) {
        line.push_back({x1, x2, y1, 1});
        line.push_back({x1, x2, y2, -1});
        X.push_back(x1);
        X.push_back(x2);
    }

    int work(int n) {
        sort(line.begin(), line.end());
        sort(X.begin(), X.end());
        int tot = unique(X.begin(), X.end()) - X.begin();
        vector<Info> init_;
        for (int i = 0; i < tot - 1; i++) {
            init_.push_back({i + 1, i + 1, 0, 0});
        }
        init(init_);
        int ans = 0;
        for (int i = 0; i < 2 * n - 1; i++) {
            modify(1, line[i].x1, line[i].x2, line[i].type);
            ans += info[1].len * (line[i + 1].y - line[i].y);
        }
        return ans;
    }

    ScanLine() : n(0) {};

    void init(const vector<Info> &_init) {
        n = (int)_init.size();
        info.assign(n * 8, Info());
        function<void(int, int, int)> build = [&](int p, int l, int r) {
            info[p].l = l;
            info[p].r = r;
            if (l == r) {
                info[p] = _init[l - 1];
                return;
            }
            int m = (l + r) / 2;
            build(2 * p, l, m);
            build(2 * p + 1, m + 1, r);
            pull(p);
        };
        build(1, 1, n);
    }

    void pull(int p) {
        if (info[p].cnt) {
            info[p].len = X[info[p].r] - X[info[p].l - 1];
        } else {
            info[p].len = info[2 * p].len + info[2 * p + 1].len;
        }
    }

    void modify(int p, int L, int R, int val) {
        int l = info[p].l;
        int r = info[p].r;
        if (X[r] <= L || R <= X[l - 1]) {
            return;
        }
        if (L <= X[l - 1] && X[r] <= R) {
            info[p].cnt += val;
            pull(p);
            return;
        }
        modify(2 * p, L, R, val);
        modify(2 * p + 1, L, R, val);
        pull(p);
    }
};
```

## 2SAT

```cpp
template <class E> struct csr {
    vector<int> r;
    vector<E> e;
    csr(int n, const vector<pair<int, E>>& edges)
        : r(n + 1), e(edges.size()) {
        for (auto e : edges) {
            r[e.first + 1]++;
        }
        for (int i = 1; i <= n; i++) {
            r[i] += r[i - 1];
        }
        auto c = r;
        for (auto e : edges) {
            e[c[e.first]++] = e.second;
        }
    }
};
         
struct scc_graph {
    int n;
    struct E {
        int to;
    };
    vector<pair<int, E>> edges;
    
    scc_graph(int n) : n(n) {}
 
    void add_edge(int u, int v) { edges.push_back({u, {v}}); }
 
    pair<int, vector<int>> work() {
        auto g = csr<E>(n, edges);
        int now = 0, siz = 0;
        vector<int> vis, low(n), ord(n, -1), ids(n);
        vis.reserve(n);
        auto dfs = [&](auto &&self, int v) -> void {
            low[v] = ord[v] = now++;
            vis.push_back(v);
            for (int i = g.r[v]; i < g.r[v + 1]; i++) {
                auto to = g.e[i].to;
                if (ord[to] == -1) {
                    self(self, to);
                    low[v] = min(low[v], low[to]);
                } else {
                    low[v] = min(low[v], ord[to]);
                }
            }
            if (low[v] == ord[v]) {
                while (true) {
                    int u = vis.back();
                    vis.pop_back();
                    ord[u] = n;
                    ids[u] = siz;
                    if (u == v) break;
                }
                siz++;
            }
        };
        for (int i = 0; i < n; i++) {
            if (ord[i] == -1) dfs(dfs, i);
        }
        return {siz, ids};
    }
 
    vector<vector<int>> scc() {
        auto ids = work();
        int siz = ids.first;
        vector<int> c(siz);
        for (auto x : ids.second) c[x]++;
        vector<vector<int>> g(ids.first);
        for (int i = 0; i < siz; i++) {
            g[i].reserve(c[i]);
        }
        for (int i = 0; i < n; i++) {
            g[ids.second[i]].push_back(i);
        }
        return g;
    }
};
     
struct two_sat {
    int n;
    vector<bool> ans;
    scc_graph scc;
    
    two_sat() : n(0), scc(0) {}
    two_sat(int n) : n(n), ans(n), scc(2 * n) {}
 
    void addClause(int i, bool f, int j, bool g) {
        scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));
        scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));
    }
    void notClause(int u, bool f, int v, bool g) {
        addClause(u, !f, v, !g) ;
    }
    bool satisfiable() {
        auto id = scc.work().second;
        for (int i = 0; i < n; i++) {
            if (id[2 * i] == id[2 * i + 1]) return false;
            ans[i] = id[2 * i] > id[2 * i + 1];
        }
        return true;
    }
};
```

